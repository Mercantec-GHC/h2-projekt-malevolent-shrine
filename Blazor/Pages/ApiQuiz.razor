@page "/api-quiz"
@inject IJSRuntime JS

<PageTitle>ASP.NET Core API Quiz</PageTitle>

<link href="css/jwt-learn.css" rel="stylesheet" />

<div class="jwt-page">
  <h1>ASP.NET Core Web API Quiz</h1>
  <p>
    Это лёгкое и понятное руководство по нашему API. Всё просто: короткие фразы, примеры из проекта, минимум умных слов — максимум пользы.
  </p>

  <div class="toc">
    <b>Разделы:</b>
    <a @onclick="@(() => ScrollToSection("map"))" style="cursor: pointer;">Карта проекта</a>
    <a @onclick="@(() => ScrollToSection("controllers"))" style="cursor: pointer;">Контроллеры и маршрутизация</a>
    <a @onclick="@(() => ScrollToSection("auth"))" style="cursor: pointer;">Роли и авторизация</a>
    <a @onclick="@(() => ScrollToSection("middleware"))" style="cursor: pointer;">Middleware и Pipeline</a>
    <a @onclick="@(() => ScrollToSection("crud"))" style="cursor: pointer;">CRUD на практике (Rooms)</a>
    <a @onclick="@(() => ScrollToSection("status-codes"))" style="cursor: pointer;">Коды ответов</a>
    <a @onclick="@(() => ScrollToSection("validation"))" style="cursor: pointer;">Валидация и DTO</a>
    <a @onclick="@(() => ScrollToSection("ef"))" style="cursor: pointer;">Entity Framework Core</a>
    <a @onclick="@(() => ScrollToSection("signalr"))" style="cursor: pointer;">SignalR уведомления</a>
    <a @onclick="@(() => ScrollToSection("http"))" style="cursor: pointer;">HTTP примеры</a>
    <a @onclick="@(() => ScrollToSection("quiz"))" style="cursor: pointer;">Финальный квиз</a>
  </div>

  <h2 id="map">Карта проекта (где что лежит)</h2>
  <ul>
    <li><code>API/Program.cs</code> — настройка сервисов, аутентификации JWT, middleware, маршрутизация.</li>
    <li><code>API/Controllers/*</code> — наши API-точки: <b>Auth</b>, <b>AdAuth</b>, <b>Rooms</b>, <b>Hotels</b>, <b>Bookings</b>, <b>CleaningTasks</b>, <b>Tickets</b>, <b>Users</b>, <b>Roles</b>, <b>VipRooms</b>, <b>Status</b>.</li>
    <li><code>API/Data/AppDBContext.cs</code> — EF Core контекст, отношения, индексы, seed-данные (роли и супер-админ).</li>
    <li><code>API/DTOs/*</code> — все модели для входа/выхода (create/read/update), чтобы не светить сущности БД наружу.</li>
    <li><code>API/Hubs/TicketHub.cs</code> — реальное время для тикетов (SignalR группы: <code>ticket-{id}</code>, <code>role-... / admins</code>).</li>
    <li><code>API/Services/*</code> — служебная логика (например, JwtService, TicketRoutingService, TelegramNotifier).</li>
    <li><code>Blazor/Services/*</code> — клиент: логин, хранение токенов, авто-refresh, вызовы API.</li>
  </ul>

  <div class="callout info">
    <div class="title">Главные идеи</div>
    <ul>
      <li>Каждый контроллер — своя тема. Путь обычно <code>api/[controller]</code>.</li>
      <li>Изменяем данные — чаще всего нужна роль (Admin/Manager/…); читаем — часто открыто или по токену.</li>
      <li>Коды ответов честные: 200/201/204 — успех, 400/401/403/404/409 — ошибки ситуации, 500 — редкая беда.</li>
    </ul>
  </div>

  <h2 id="controllers">Контроллеры и маршрутизация</h2>
  <p>Основы создания API endpoints в ASP.NET Core.</p>
  <ul>
    <li><code>[ApiController]</code> — автоматическая валидация и 400 ответы.</li>
    <li><code>[Route("api/[controller]")]</code> — шаблон пути, напр.: <code>/api/Rooms</code>, <code>/api/Tickets</code>.</li>
    <li><code>[HttpGet]</code>, <code>[HttpPost]</code>, <code>[HttpPut]</code>, <code>[HttpDelete]</code>, <code>[HttpGet("{id}")]</code>.</li>
  </ul>
  <p><b>Примеры из проекта</b> (упрощённо):</p>
  <pre>
// RoomsController
GET    /api/Rooms                // список номеров
GET    /api/Rooms/{id}           // один номер (404 если нет)
POST   /api/Rooms                // создание (нужна роль)
PUT    /api/Rooms/{id}           // обновление (нужна роль)
DELETE /api/Rooms/{id}           // удаление (нужна роль)
GET    /api/Rooms/availability?days=28&amp;hotelId=1 // публично

// TicketsController (требует токен на весь контроллер)
GET /api/Tickets/mine
GET /api/Tickets/for-role
POST /api/Tickets                // создать тикет
POST /api/Tickets/{id}/assign    // взять в работу (роль)
POST /api/Tickets/{id}/status    // сменить статус
POST /api/Tickets/messages       // добавить сообщение
  </pre>

  <h2 id="auth">Роли и авторизация (по-простому)</h2>
  <ul>
    <li><code>[Authorize]</code> — нужен действующий токен (иначе 401).</li>
    <li><code>[Authorize(Roles = "Admin,Manager,InfiniteVoid")]</code> — нужен токен и одна из перечисленных ролей (иначе 403).</li>
    <li><code>[AllowAnonymous]</code> — доступ всем (даже без токена).</li>
  </ul>
  <p>Как у нас:</p>
  <ul>
    <li><b>TicketsController</b> — весь закрыт <code>[Authorize]</code>. Без токена — 401.</li>
    <li><b>RoomsController</b> — чтение открыто, изменения только для <b>Admin/Manager/InfiniteVoid</b>.</li>
    <li><b>Rooms/availability</b> — <code>[AllowAnonymous]</code>, можно смотреть без логина.</li>
  </ul>

  <h2 id="middleware">Middleware и Pipeline</h2>
  <p>Обработка HTTP-запросов через цепочку компонентов. Главное — порядок.</p>
  <ul>
    <li>Обычно: <b>UseRouting → UseAuthentication → UseAuthorization</b>.</li>
    <li>Можно добавить свои middleware (логирование, обработка ошибок).</li>
  </ul>

  <h2 id="crud">CRUD на практике: Rooms</h2>
  <p>Живой пример на реальном контроллере.</p>
  <pre>
POST /api/Rooms            // 201 Created + Location заголовок (CreatedAtAction)
PUT  /api/Rooms/{id}       // 204 No Content при успехе, 400 если id не совпал, 404 если нет записи
DEL  /api/Rooms/{id}       // 204 No Content, 404 если нет

Ошибки бизнес-логики:
- Дубликат номера в отеле → 409 Conflict (уникальный индекс HotelId+Number)

Публичный просмотр занятости:
GET /api/Rooms/availability?days=28&amp;hotelId=1
- days: по умолчанию 28, максимум 60
- hotelId: необязательный фильтр
  </pre>

  <h2 id="status-codes">Коды ответов: коротко и ясно</h2>
  <ul>
    <li><b>200 OK</b> — всё ок, есть данные.</li>
    <li><b>201 Created</b> — создан ресурс (обычно вместе с Location).</li>
    <li><b>204 No Content</b> — всё ок, но тела нет (после PUT/DELETE).</li>
    <li><b>400 BadRequest</b> — плохие входные данные (валидация/несовпадение id).</li>
    <li><b>401 Unauthorized</b> — нет токена или он невалиден.</li>
    <li><b>403 Forbidden</b> — токен есть, но роли не хватает.</li>
    <li><b>404 NotFound</b> — не нашли запись по id.</li>
    <li><b>409 Conflict</b> — конфликт уникальности (например, номер комнаты).</li>
    <li><b>500 InternalServerError</b> — редкая ошибка сервера.</li>
  </ul>

  <h2 id="validation">Валидация и DTO</h2>
  <p>Проверка входных данных и паттерн Data Transfer Object.</p>
  <ul>
    <li>DataAnnotations: <code>[Required]</code>, <code>[StringLength]</code>, <code>[EmailAddress]</code> и т.д. — ставим на DTO.</li>
    <li>В контроллере часто есть <code>if (!ModelState.IsValid) return BadRequest(ModelState);</code>.</li>
    <li><code>[FromBody]</code> — брать JSON из тела запроса; <code>[FromQuery]</code> — из строки запроса.</li>
    <li>DTO отделяют базу от API: например, <code>RoomCreateDto/RoomUpdateDto/RoomReadDto</code>.</li>
  </ul>

  <h2 id="ef">Entity Framework Core</h2>
  <p>ORM для работы с базами данных.</p>
  <ul>
    <li><b>AppDBContext</b> — точка входа. Здесь связи, индексы, значения по умолчанию.</li>
    <li>Уникальные индексы: <code>User.Email</code>, <code>User.Username</code>, <code>(Room.HotelId, Room.Number)</code>.</li>
    <li>Seed-данные ролей: Admin, Manager, Rengørring, Kunde, InfiniteVoid. Плюс супер-админ (Gojo).</li>
    <li>Для чтения быстрее: <code>AsNoTracking()</code> (например, в доступности комнат).</li>
    <li>Миграции — версионирование схемы БД.</li>
  </ul>

  <h2 id="signalr">SignalR: живые уведомления</h2>
  <ul>
    <li>Когда создаём тикет — рассылаем событие в группу роли: <code>role-{RoleName}</code> и тост в <code>admins</code>.</li>
    <li>Изменения по конкретному тикету — в группу <code>ticket-{id}</code>.</li>
    <li>Это помогает видеть новые заявки и обновления без перезагрузки страницы.</li>
  </ul>

  <h2 id="http">HTTP примеры (как готовить)</h2>
  <pre>
# Регистрация/Логин
POST /api/Auth/register
POST /api/Auth/login
// Ответ: { accessToken, refreshToken, ... }
// Дальше — все закрытые запросы с заголовком:
Authorization: Bearer &lt;accessToken&gt;

# Обновить токены
POST /api/Auth/refresh-token
{ "refreshToken": "..." }

# Тикеты (нужен токен)
GET  /api/Tickets/mine
POST /api/Tickets
{ "title": "TV broken", "category": "Tech", "description": "No signal" }

# Комнаты
GET  /api/Rooms
GET  /api/Rooms/availability?days=14&amp;hotelId=2
POST /api/Rooms                     // Admin/Manager/InfiniteVoid
PUT  /api/Rooms/{id}
DEL  /api/Rooms/{id}
  </pre>

  <h2 id="quiz">Финальный квиз</h2>
  <p>Проверь свои знания ASP.NET Core Web API на примерах из проекта. Жми на вариант — сразу увидишь ответ.</p>
  <div class="quiz">
    @for (int i = 0; i < _questions.Count; i++)
    {
        var questionIndex = i;
        var q = _questions[questionIndex];
        <div class="q">
          <div class="qtext"><b>@(questionIndex+1).</b> @q.Text</div>
          <div class="opts">
            @for (int j = 0; j < q.Options.Count; j++)
            {
                var optionIndex = j;
                var opt = q.Options[optionIndex];
                var chosen = q.SelectedIndex == optionIndex;
                var cls = q.Answered
                    ? (optionIndex == q.CorrectIndex ? "opt correct" : (chosen ? "opt wrong" : "opt"))
                    : (chosen ? "opt chosen" : "opt");
                <button class="@cls" type="button" @onclick="@(() => SelectAnswer(questionIndex, optionIndex))" disabled="@q.Answered">@opt</button>
            }
          </div>
          @if (q.Answered)
          {
            var isCorrect = q.SelectedIndex == q.CorrectIndex;
            <div class="feedback @(isCorrect ? "correct" : "wrong")">
                @(isCorrect ? "Верно! ✓" : "Неверно. ✗")
            </div>
            @if (!string.IsNullOrWhiteSpace(q.Explanation))
            {
              <div class="explain"><b>Объяснение:</b> @q.Explanation</div>
            }
          }
        </div>
    }
    <div class="quiz-actions">
      <button class="btn" type="button" @onclick="ShowScore">Показать результат</button>
      <button class="btn ghost" type="button" @onclick="ResetQuiz">Сбросить</button>
    </div>
    @if (_scoreVisible)
    {
      <div class="score">Результат: <b>@CorrectCount</b> из <b>@_questions.Count</b> — @(ScoreComment)</div>
    }
  </div>

  <div class="nav-buttons">
    <a href="/" class="btn">На главную</a>
  </div>
</div>

@code {
  private async Task ScrollToSection(string sectionId)
  {
      try
      {
          await JS.InvokeVoidAsync("eval", $"document.getElementById('{sectionId}')?.scrollIntoView({{ behavior: 'smooth', block: 'start' }});");
      }
      catch (Exception ex)
      {
          Console.WriteLine($"[SCROLL] Error: {ex.Message}");
      }
  }

  class QuizQuestion
  {
      public string Text { get; set; } = string.Empty;
      public List<string> Options { get; set; } = new();
      public int CorrectIndex { get; set; }
      public string? Explanation { get; set; }
      public int? SelectedIndex { get; set; }
      public bool Answered { get; set; }
  }

  private List<QuizQuestion> _questions = new();
  private bool _scoreVisible;
  private readonly Random _rng = new Random();
  
  int CorrectCount => _questions.Count(q => q.Answered && q.SelectedIndex == q.CorrectIndex);
  string ScoreComment => CorrectCount switch
  {
      >= 12 => "API Мастер! 🚀",
      >= 9 => "Отлично знаешь API! 👍",
      >= 6 => "Хорошая база! 🙂",
      _ => "Стоит повторить материал 📚"
  };

  void SelectAnswer(int qi, int oi)
  {
      if (qi < 0 || qi >= _questions.Count) return;
      var q = _questions[qi];
      if (oi < 0 || oi >= q.Options.Count) return;
      q.SelectedIndex = oi;
      q.Answered = true;
      StateHasChanged();
  }

  void ShowScore()
  {
      _scoreVisible = true;
      StateHasChanged();
  }

  void ResetQuiz()
  {
      foreach (var q in _questions)
      {
          q.SelectedIndex = null;
          q.Answered = false;
      }
      _scoreVisible = false;
      StateHasChanged();
  }

  protected override void OnInitialized()
  {
      if (_questions.Count == 0)
      {
          _questions = BuildQuestions();
          // Перемешать варианты ответов у каждого вопроса один раз при инициализации
          foreach (var q in _questions)
          {
              ShuffleOptions(q);
          }
      }
  }

  void ShuffleOptions(QuizQuestion q)
  {
      if (q.Options.Count <= 1) return;
      var n = q.Options.Count;
      // Индексы исходного порядка
      var idx = Enumerable.Range(0, n).ToList();
      // Фишера-Йетса
      for (int i = n - 1; i > 0; i--)
      {
          int j = _rng.Next(i + 1);
          (idx[i], idx[j]) = (idx[j], idx[i]);
      }
      // Собрать новый порядок опций
      var newOptions = new List<string>(n);
      for (int k = 0; k < n; k++) newOptions.Add(q.Options[idx[k]]);
      // Найти новую позицию правильного ответа
      var newCorrect = idx.IndexOf(q.CorrectIndex);
      q.Options = newOptions;
      q.CorrectIndex = newCorrect;
  }

  List<QuizQuestion> BuildQuestions()
  {
      return new List<QuizQuestion>
      {
          Q("Какой атрибут делает класс API контроллером?",
            new[]{"[ApiController]", "[Controller]", "[RestController]"}, 0,
            "[ApiController] включает автоматическую валидацию ModelState и другие удобства."),
          
          Q("Какой HTTP-метод используется для создания ресурса?",
            new[]{"POST", "GET", "PUT"}, 0,
            "POST — стандарт для создания новых ресурсов."),
          
          Q("Что возвращает IActionResult?",
            new[]{"HTTP-ответ", "JSON объект", "Строку"}, 0,
            "IActionResult — интерфейс для различных типов HTTP-ответов (200, 404, 400 и т.д.)."),
          
          Q("Какой порядок middleware правильный?",
            new[]{"Routing → Authentication → Authorization", "Authorization → Authentication → Routing", "Authentication → Routing → Authorization"}, 0,
            "Сначала маршрутизация, затем аутентификация, затем авторизация."),
          
          Q("Что делает [FromBody] атрибут?",
            new[]{"Парсит JSON из тела запроса", "Читает query параметры", "Берет данные из route"}, 0,
            "[FromBody] указывает, что параметр должен быть десериализован из JSON тела запроса."),
          
          Q("Какой код возвращать при успешном создании?",
            new[]{"201 Created", "200 OK", "204 No Content"}, 0,
            "201 Created — стандартный код для успешно созданного ресурса."),
          
          Q("Что такое DTO?",
            new[]{"Data Transfer Object", "Database Transfer Object", "Dynamic Type Object"}, 0,
            "DTO — паттерн для передачи данных между слоями приложения."),
          
          Q("Для чего нужен AsNoTracking()?",
            new[]{"Повышение производительности read-only запросов", "Отключение логирования", "Удаление кэша"}, 0,
            "AsNoTracking отключает отслеживание изменений Entity Framework, ускоряя read-only операции."),

          // Новые вопросы про наш проект
          Q("Какой путь у контроллера Rooms по умолчанию?",
            new[]{"/api/Rooms", "/rooms", "/api/Room"}, 0,
            "[Route(\"api/[controller]\")] → имя контроллера RoomsController даёт путь /api/Rooms."),

          Q("Какие роли могут СОЗДАВАТЬ/ОБНОВЛЯТЬ/УДАЛЯТЬ комнаты?",
            new[]{"Admin, Manager, InfiniteVoid", "Любой авторизованный", "Только Admin"}, 0,
            "В RoomsController на POST/PUT/DELETE стоит [Authorize(Roles = \"Admin,Manager,InfiniteVoid\")]."),

          Q("Что вернёт POST /api/Rooms при успехе?",
            new[]{"201 Created и Location заголовок", "200 OK без тела", "204 No Content"}, 0,
            "Создание комнаты возвращает CreatedAtAction → 201 и ссылку на ресурс."),

          Q("Что вернёт PUT /api/Rooms/{id} при успехе?",
            new[]{"204 No Content", "200 OK с комнатой", "201 Created"}, 0,
            "По коду — NoContent() (без тела)."),

          Q("Максимум дней в /api/Rooms/availability?",
            new[]{"60", "28", "7"}, 0,
            "В контроллере: если days > 60 → берём 60."),

          Q("Без токена к TicketsController…",
            new[]{"Не пустит (401)", "Пустит, но только GET", "Пустит, если есть роль"}, 0,
            "На всём TicketsController — [Authorize]."),

          Q("Если токен есть, но роли не хватает, какой код?",
            new[]{"403 Forbidden", "401 Unauthorized", "404 NotFound"}, 0,
            "Недостаточно прав → 403."),

          Q("Дубликат номера комнаты в одном отеле даёт…",
            new[]{"409 Conflict", "400 BadRequest", "500 Internal"}, 0,
            "Есть уникальный индекс (HotelId, Number) и ловим конфликт — 409."),

          Q("Где в проекте сидят роли по умолчанию?",
            new[]{"AppDBContext.OnModelCreating (HasData)", "appsettings.json", "Blazor Program.cs"}, 0,
            "Роли seed-ятся в AppDBContext через HasData."),

          Q("Что делает [FromQuery] в GetAvailability?",
            new[]{"Берёт значения из строки запроса", "Читает тело запроса", "Бросает исключение"}, 0,
            "Параметры days, hotelId приходят из query (?days=&amp;hotelId=)."),

          Q("Что вернёт GET /api/Rooms/99999 если комнаты нет?",
            new[]{"404 NotFound", "200 OK с пустым объектом", "204 No Content"}, 0,
            "Контроллер явно возвращает NotFound() если запись не найдена."),

          Q("Что использовать, чтобы сказать клиенту ‘всё ок, но тела нет’?",
            new[]{"204 No Content", "201 Created", "409 Conflict"}, 0,
            "Например, после успешного PUT или DELETE."),
      };
  }

  static QuizQuestion Q(string text, string[] options, int correct, string? explanation = null)
  {
      return new QuizQuestion
      {
          Text = text,
          Options = options.ToList(),
          CorrectIndex = correct,
          Explanation = explanation
      };
  }
}
