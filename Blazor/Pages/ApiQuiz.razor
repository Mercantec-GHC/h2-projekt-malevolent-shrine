@page "/api-quiz"
@inject IJSRuntime Js

<PageTitle>ASP.NET Core API Quiz</PageTitle>

<link href="css/jwt-learn.css" rel="stylesheet" />

<div class="jwt-page">
  <h1>ASP.NET Core Web API Quiz</h1>
  <p>
    Это лёгкое и понятное руководство по нашему API. Всё просто: короткие фразы, примеры из проекта, минимум умных слов — максимум пользы.
  </p>

  <div class="toc">
    <b>Разделы:</b>
    <a @onclick="@(() => ScrollToSection("map"))" style="cursor: pointer;">Карта проекта</a>
    <a @onclick="@(() => ScrollToSection("models"))" style="cursor: pointer;">Модели (сущности) простыми словами</a>
    <a @onclick="@(() => ScrollToSection("models-deep"))" style="cursor: pointer;">Разбор моделей по‑простому</a>
    <a @onclick="@(() => ScrollToSection("relations"))" style="cursor: pointer;">Как связаны данные</a>
    <a @onclick="@(() => ScrollToSection("controllers"))" style="cursor: pointer;">Контроллеры и маршрутизация</a>
    <a @onclick="@(() => ScrollToSection("auth"))" style="cursor: pointer;">Роли и авторизация</a>
    <a @onclick="@(() => ScrollToSection("middleware"))" style="cursor: pointer;">Middleware и Pipeline</a>
    <a @onclick="@(() => ScrollToSection("crud"))" style="cursor: pointer;">CRUD на практике (Rooms)</a>
    <a @onclick="@(() => ScrollToSection("status-codes"))" style="cursor: pointer;">Коды ответов</a>
    <a @onclick="@(() => ScrollToSection("validation"))" style="cursor: pointer;">Валидация и DTO</a>
    <a @onclick="@(() => ScrollToSection("ef"))" style="cursor: pointer;">Entity Framework Core</a>
    <a @onclick="@(() => ScrollToSection("signalr"))" style="cursor: pointer;">SignalR уведомления</a>
    <a @onclick="@(() => ScrollToSection("http"))" style="cursor: pointer;">HTTP примеры</a>
    <a @onclick="@(() => ScrollToSection("scenarios"))" style="cursor: pointer;">Жизненные сценарии</a>
    <a @onclick="@(() => ScrollToSection("quiz"))" style="cursor: pointer;">Финальный квиз</a>
  </div>

  <h2 id="map">Карта проекта (где что лежит)</h2>
  <ul>
    <li><code>API/Program.cs</code> — настройка сервисов, аутентификации JWT, middleware, маршрутизация.</li>
    <li><code>API/Controllers/*</code> — наши API-точки: <b>Auth</b>, <b>AdAuth</b>, <b>Rooms</b>, <b>Hotels</b>, <b>Bookings</b>, <b>CleaningTasks</b>, <b>Tickets</b>, <b>Users</b>, <b>Roles</b>, <b>VipRooms</b>, <b>Status</b>.</li>
    <li><code>API/Data/AppDBContext.cs</code> — EF Core контекст, отношения, индексы, seed-данные (роли и супер-админ).</li>
    <li><code>API/DTOs/*</code> — все модели для входа/выхода (create/read/update), чтобы не светить сущности БД наружу.</li>
    <li><code>API/Hubs/TicketHub.cs</code> — реальное время для тикетов (SignalR группы: <code>ticket-{id}</code>, <code>role-... / admins</code>).</li>
    <li><code>API/Services/*</code> — служебная логика (например, JwtService, TicketRoutingService, TelegramNotifier).</li>
    <li><code>Blazor/Services/*</code> — клиент: логин, хранение токенов, авто-refresh, вызовы API.</li>
  </ul>

  <div class="callout info">
    <div class="title">Главные идеи</div>
    <ul>
      <li>Каждый контроллер — своя тема. Путь обычно <code>api/[controller]</code>.</li>
      <li>Изменяем данные — чаще всего нужна роль (Admin/Manager/…); читаем — часто открыто или по токену.</li>
      <li>Коды ответов честные: 200/201/204 — успех, 400/401/403/404/409 — ошибки ситуации, 500 — редкая беда.</li>
    </ul>
  </div>

  <h2 id="models">Модели (сущности БД) простыми словами</h2>
  <p>Это таблицы в БД. Мы храним факты. Коротко: что это и зачем.</p>
  <ul>
    <li><b>User</b> — человек в системе. Поля: имя/фамилия, <code>Email</code>, <code>Username</code>, <code>HashedPassword</code> (пароль в виде хеша), дата рождения (<code>IsAdult</code> вычисляется), <code>RoleId</code> (кто он), <code>IsVIP</code>, аватар. У пользователя есть <code>RefreshTokens</code> (для обновления доступа).</li>
    <li><b>Role</b> — роль: Admin, Manager, Rengørring, Kunde, InfiniteVoid. Простой справочник. Пользователь ссылается на роль.</li>
    <li><b>Hotel</b> — отель: имя, адрес, картинка. Имеет список комнат <code>Rooms</code>.</li>
    <li><b>Room</b> — комната/номер: <code>Number</code> (уникален внутри отеля), вместимость, цена за ночь, этаж, доступность, описание, картинка, <code>HotelId</code>.</li>
    <li><b>VipRoom</b> — как Room, но с особыми услугами: <code>VipServiceDescription</code> + <code>ExtraAmenities</code>. Наследуется от <code>Room</code>.</li>
    <li><b>Booking</b> — бронь комнаты: кто (<code>UserId</code>), что (<code>RoomId</code>), заезд/выезд, цена, статус.</li>
    <li><b>Ticket</b> — заявка/проблема: заголовок, категория (<code>Cleaning/Technical/General</code>), статус, кто создал, кому адресовано (<code>TargetRoleName</code>), кому назначено, сообщения.</li>
    <li><b>TicketMessage</b> — сообщение внутри тикета: текст, кто отправил, к какому тикету относится.</li>
    <li><b>CleaningTask</b> — задача по уборке: заголовок, описание, номер, кому назначили (уборщику), кто создал, дедлайн, статус.</li>
    <li><b>RefreshToken</b> — «пропуск на продление доступа». Храним не сам токен, а <code>TokenHash</code> (безопаснее), срок годности, признак отзыва, связь с пользователем.</li>
    <li><b>UserInfo</b> — доп. профиль пользователя (телефон, адрес, аватар). Отдельно, чтобы не раздувать <code>User</code>.</li>
    <li><b>Common</b> — базовый класс для сущностей: <code>Id</code>, <code>CreatedAt</code>, <code>UpdatedAt</code>.</li>
  </ul>
  <div class="callout">
    <div class="title">Почему такие поля?</div>
    <ul>
      <li><b>Room.Number</b> + <b>HotelId</b> — вместе уникальны: нельзя две комнаты «101» в одном отеле, но можно в разных.</li>
      <li><b>RefreshToken.TokenHash</b> — храним хеш, а не токен, чтобы даже из БД нельзя было украсть «пропуск».</li>
      <li><b>Ticket.TargetRoleName</b> — сразу понимаем, какой отдел увидит заявку (например, уборка).</li>
      <li><b>Common.CreatedAt/UpdatedAt</b> — удобно видеть, когда запись создана/менялась.</li>
    </ul>
  </div>

  <h2 id="relations">Как связаны данные</h2>
  <ul>
    <li><b>Hotel</b> 1 → N <b>Room</b> (у отеля много комнат).</li>
    <li><b>User</b> 1 → N <b>Booking</b> (у пользователя много броней).</li>
    <li><b>Room</b> 1 → N <b>Booking</b> (в одну комнату разные даты брони).</li>
    <li><b>Ticket</b> 1 → N <b>TicketMessage</b> (как чат сообщениями).</li>
    <li><b>User</b> 1 → N <b>RefreshToken</b> (несколько активных/исторических токенов).</li>
  </ul>

  <h2 id="controllers">Контроллеры и маршрутизация</h2>
  <p>Основы создания API endpoints в ASP.NET Core.</p>
  <ul>
    <li><code>[ApiController]</code> — автоматическая валидация и 400 ответы.</li>
    <li><code>[Route("api/[controller]")]</code> — шаблон пути, напр.: <code>/api/Rooms</code>, <code>/api/Tickets</code>.</li>
    <li><code>[HttpGet]</code>, <code>[HttpPost]</code>, <code>[HttpPut]</code>, <code>[HttpDelete]</code>, <code>[HttpGet("{id}")]</code>.</li>
  </ul>
  <p><b>Примеры из проекта</b> (упрощённо):</p>
  <pre>
// RoomsController
GET    /api/Rooms                // список номеров
GET    /api/Rooms/{id}           // один номер (404 если нет)
POST   /api/Rooms                // создание (нужна роль)
PUT    /api/Rooms/{id}           // обновление (нужна роль)
DELETE /api/Rooms/{id}           // удаление (нужна роль)
GET    /api/Rooms/availability?days=28&amp;hotelId=1 // публично

// TicketsController (требует токен на весь контроллер)
GET /api/Tickets/mine
GET /api/Tickets/for-role
POST /api/Tickets                // создать тикет
POST /api/Tickets/{id}/assign    // взять в работу (роль)
POST /api/Tickets/{id}/status    // сменить статус
POST /api/Tickets/messages       // добавить сообщение
  </pre>

  <h2 id="auth">Роли и авторизация (по-простому)</h2>
  <ul>
    <li><code>[Authorize]</code> — нужен действующий токен (иначе 401).</li>
    <li><code>[Authorize(Roles = "Admin,Manager,InfiniteVoid")]</code> — нужен токен и одна из перечисленных ролей (иначе 403).</li>
    <li><code>[AllowAnonymous]</code> — доступ всем (даже без токена).</li>
  </ul>
  <p>Как у нас:</p>
  <ul>
    <li><b>TicketsController</b> — весь закрыт <code>[Authorize]</code>. Без токена — 401.</li>
    <li><b>RoomsController</b> — чтение открыто, изменения только для <b>Admin/Manager/InfiniteVoid</b>.</li>
    <li><b>Rooms/availability</b> — <code>[AllowAnonymous]</code>, можно смотреть без логина.</li>
  </ul>

  <h2 id="middleware">Middleware и Pipeline</h2>
  <p>Обработка HTTP-запросов через цепочку компонентов. Главное — порядок.</p>
  <ul>
    <li>Обычно: <b>UseRouting → UseAuthentication → UseAuthorization</b>.</li>
    <li>Можно добавить свои middleware (логирование, обработка ошибок).</li>
  </ul>

  <h2 id="crud">CRUD на практике: Rooms</h2>
  <p>Живой пример на реальном контроллере.</p>
  <pre>
POST /api/Rooms            // 201 Created + Location заголовок (CreatedAtAction)
PUT  /api/Rooms/{id}       // 204 No Content при успехе, 400 если id не совпал, 404 если нет записи
DEL  /api/Rooms/{id}       // 204 No Content, 404 если нет

Ошибки бизнес-логики:
- Дубликат номера в отеле → 409 Conflict (уникальный индекс HotelId+Number)

Публичный просмотр занятости:
GET /api/Rooms/availability?days=28&amp;hotelId=1
- days: по умолчанию 28, максимум 60
- hotelId: необязательный фильтр
  </pre>

  <h2 id="status-codes">Коды ответов: коротко и ясно</h2>
  <ul>
    <li><b>200 OK</b> — всё ок, есть данные.</li>
    <li><b>201 Created</b> — создан ресурс (обычно вместе с Location).</li>
    <li><b>204 No Content</b> — всё ок, но тела нет (после PUT/DELETE).</li>
    <li><b>400 BadRequest</b> — плохие входные данные (валидация/несовпадение id).</li>
    <li><b>401 Unauthorized</b> — нет токена или он невалиден.</li>
    <li><b>403 Forbidden</b> — токен есть, но роли не хватает.</li>
    <li><b>404 NotFound</b> — не нашли запись по id.</li>
    <li><b>409 Conflict</b> — конфликт уникальности (например, номер комнаты).</li>
    <li><b>500 InternalServerError</b> — редкая ошибка сервера.</li>
  </ul>

  <h2 id="validation">Валидация и DTO</h2>
  <p>DTO — простые сумки для данных, которыми мы обмениваемся через API. Сущности — это то, как мы храним в БД. Мы никогда не отдаём наружу пароли/внутренние поля.</p>
  <ul>
    <li><b>RoomCreateDto / RoomUpdateDto / RoomReadDto</b> — создать/обновить/читать номер. На входе просим только нужное (номер, этаж, цена), на выходе даём Id и доп. данные.</li>
    <li><b>BookingCreateDto / BookingUpdateDto / BookingReadDto</b> — работа с бронями (даты, цена, статус). Read-версия содержит <code>CreatedAt</code>, <code>HotelName</code>, <code>RoomNumber</code>.</li>
    <li><b>TicketCreateDto / TicketMessageCreateDto / TicketReadDto</b> — заявки и сообщения (категория, описание, потом переписка).</li>
    <li><b>CleaningTaskCreateDto / CleaningTaskReadDto</b> — задачи уборки (кому назначили, статус).</li>
    <li><b>AuthDto / UserLoginDto / AuthResponseDto / RefreshTokenDto</b> — регистрация, вход, ответ с токенами, обновление токена.</li>
  </ul>
  <div class="callout">
    <div class="title">Как это помогает</div>
    <ul>
      <li>Безопасность: наружу не утекает <code>HashedPassword</code> и прочие внутренние поля.</li>
      <li>Удобство: для создания комнаты не нужно знать всё про комнату — только важное.</li>
      <li>Стабильность: можно менять сущности в БД, не ломая контракт API.</li>
    </ul>
  </div>

  <h2 id="ef">Entity Framework Core</h2>
  <p>ORM для работы с базами данных.</p>
  <ul>
    <li><b>AppDBContext</b> — точка входа. Здесь связи, индексы, значения по умолчанию.</li>
    <li>Уникальные индексы: <code>User.Email</code>, <code>User.Username</code>, <code>(Room.HotelId, Room.Number)</code>.</li>
    <li>Seed-данные ролей: Admin, Manager, Rengørring, Kunde, InfiniteVoid. Плюс супер-админ (Gojo).</li>
    <li>Для чтения быстрее: <code>AsNoTracking()</code> (например, в доступности комнат).</li>
    <li>Базовый класс <code>Common</code>: даёт всем сущностям <code>Id</code>, <code>CreatedAt</code>, <code>UpdatedAt</code>.</li>
  </ul>

  <h2 id="signalr">SignalR: живые уведомления</h2>
  <ul>
    <li>Когда создаём тикет — рассылаем событие в группу роли: <code>role-{RoleName}</code> и тост в <code>admins</code>.</li>
    <li>Изменения по конкретному тикету — в группу <code>ticket-{id}</code>.</li>
    <li>Это помогает видеть новые заявки и обновления без перезагрузки страницы.</li>
  </ul>

  <h2 id="http">HTTP примеры (как готовить)</h2>
  <pre>
# Регистрация/Логин
POST /api/Auth/register
POST /api/Auth/login
// Ответ: { accessToken, refreshToken, ... }
// Дальше — все закрытые запросы с заголовком:
Authorization: Bearer &lt;accessToken&gt;

# Обновить токены
POST /api/Auth/refresh-token
{ "refreshToken": "..." }

# Тикеты (нужен токен)
GET  /api/Tickets/mine
POST /api/Tickets
{ "title": "TV broken", "category": "Tech", "description": "No signal" }

# Комнаты
GET  /api/Rooms
GET  /api/Rooms/availability?days=14&amp;hotelId=2
POST /api/Rooms                     // Admin/Manager/InfiniteVoid
PUT  /api/Rooms/{id}
DEL  /api/Rooms/{id}
  </pre>

  <div class="callout info">
    <div class="title">Примеры JSON тел (DTO «как есть»)</div>
    <p>Так выглядят данные, которые мы отправляем/получаем. Просто копируй и меняй значения.</p>
    <pre>
// Создать комнату (RoomCreateDto)
{
  "number": "101",
  "capacity": 2,
  "pricePerNight": 120.0,
  "floor": 1,
  "isAvailable": true,
  "hotelId": 1
}

// Обновить комнату (RoomUpdateDto)
{
  "id": 5,
  "number": "101",
  "capacity": 3,
  "pricePerNight": 140.0,
  "floor": 1,
  "isAvailable": false,
  "hotelId": 1
}

// Прочитать комнату (RoomReadDto — пример ответа)
{
  "id": 5,
  "number": "101",
  "capacity": 3,
  "pricePerNight": 140.0,
  "floor": 1,
  "isAvailable": false,
  "hotelId": 1,
  "description": "Уютный номер",
  "imageUrl": "/img/101.jpg"
}

// Создать бронь (BookingCreateDto)
{
  "userId": 12,
  "roomId": 5,
  "checkInDate": "2025-10-10T15:00:00Z",
  "checkOutDate": "2025-10-12T11:00:00Z",
  "totalPrice": 280.0,
  "status": "Pending"
}

// Создать тикет (TicketCreateDto)
{
  "title": "TV broken",
  "category": 1,              // Technical
  "description": "No signal",
  "bookingId": null,
  "roomId": 5
}

// Сообщение в тикете (TicketMessageCreateDto)
{
  "ticketId": 33,
  "content": "Мы уже идём чинить"
}

// Задача на уборку (CleaningTaskCreateDto)
{
  "title": "Убраться после выезда",
  "description": "Нужно помыть пол, заменить постель",
  "roomId": 5,
  "assignedToUserId": 21,
  "dueDate": "2025-10-07T10:00:00Z"
}

// Регистрация (AuthDto)
{
  "username": "mario",
  "password": "123456",
  "email": "mario@example.com",
  "firstName": "Mario",
  "lastName": "Rossi"
}

// Логин (UserLoginDto)
{
  "email": "mario@example.com",
  "password": "123456"
}

// Обновить токен (RefreshTokenDto)
{
  "refreshToken": "&lt;long-random-string&gt;"
}
    </pre>
  </div>

  <h2 id="scenarios">Жизненные сценарии (от запроса до ответа)</h2>
  <ul>
    <li><b>Гость бронирует номер:</b> создаём <code>Booking</code> через <code>POST /api/Bookings</code>. Сервис проверяет даты, считает цену, сохраняет. Ответ — <code>201 Created</code> + данные брони.</li>
    <li><b>Сломался телевизор:</b> гость создаёт <code>Ticket</code>. Система определяет <code>TargetRoleName</code> (например, Manager/Technical). Уведомление улетает в группы роли и в конкретный тикет (SignalR).</li>
    <li><b>Уборка:</b> менеджер создаёт <code>CleaningTask</code> и назначает сотрудника. Тот видит свои задания и отмечает статус.</li>
    <li><b>Продление сессии:</b> фронт отправляет <code>RefreshToken</code>. На сервере сравниваем хеши (<code>TokenHash</code>), проверяем срок и «отозван ли». Если всё ок — выдаём новую пару токенов.</li>
  </ul>

  <h2 id="quiz">Финальный квиз</h2>
  <p>Проверь свои знания ASP.NET Core Web API на примерах из проекта. Жми на вариант — сразу увидишь ответ.</p>
  <div class="quiz">
    @for (int i = 0; i < _questions.Count; i++)
    {
        var questionIndex = i;
        var q = _questions[questionIndex];
        <div class="q">
          <div class="qtext"><b>@(questionIndex+1).</b> @q.Text</div>
          <div class="opts">
            @for (int j = 0; j < q.Options.Count; j++)
            {
                var optionIndex = j;
                var opt = q.Options[optionIndex];
                var chosen = q.SelectedIndex == optionIndex;
                var cls = q.Answered
                    ? (optionIndex == q.CorrectIndex ? "opt correct" : (chosen ? "opt wrong" : "opt"))
                    : (chosen ? "opt chosen" : "opt");
                <button class="@cls" type="button" @onclick="@(() => SelectAnswer(questionIndex, optionIndex))" disabled="@q.Answered">@opt</button>
            }
          </div>
          @if (q.Answered)
          {
            var isCorrect = q.SelectedIndex == q.CorrectIndex;
            <div class="feedback @(isCorrect ? "correct" : "wrong")">
                @(isCorrect ? "Верно! ✓" : "Неверно. ✗")
            </div>
            @if (!string.IsNullOrWhiteSpace(q.Explanation))
            {
              <div class="explain"><b>Объяснение:</b> @q.Explanation</div>
            }
          }
        </div>
    }
    <div class="quiz-actions">
      <button class="btn" type="button" @onclick="ShowScore">Показать результат</button>
      <button class="btn ghost" type="button" @onclick="ResetQuiz">Сбросить</button>
    </div>
    @if (_scoreVisible)
    {
      <div class="score">Результат: <b>@CorrectCount</b> из <b>@_questions.Count</b> — @(ScoreComment)</div>
    }
  </div>

  <div class="nav-buttons">
    <a href="/" class="btn">На главную</a>
  </div>
</div>

@code {
  private async Task ScrollToSection(string sectionId)
  {
      try
      {
          await Js.InvokeVoidAsync("eval", $"document.getElementById('{sectionId}')?.scrollIntoView({{ behavior: 'smooth', block: 'start' }});");
      }
      catch (Exception ex)
      {
          Console.WriteLine($"[SCROLL] Error: {ex.Message}");
      }
  }

  class QuizQuestion
  {
      public string Text { get; set; } = string.Empty;
      public List<string> Options { get; set; } = new();
      public int CorrectIndex { get; set; }
      public string? Explanation { get; set; }
      public int? SelectedIndex { get; set; }
      public bool Answered { get; set; }
  }

  private List<QuizQuestion> _questions = new();
  private bool _scoreVisible;
  private readonly Random _rng = new Random();
  
  int CorrectCount => _questions.Count(q => q.Answered && q.SelectedIndex == q.CorrectIndex);
  string ScoreComment => CorrectCount switch
  {
      >= 12 => "API Мастер! 🚀",
      >= 9 => "Отлично знаешь API! 👍",
      >= 6 => "Хорошая база! 🙂",
      _ => "Стоит повторить материал 📚"
  };

  void SelectAnswer(int qi, int oi)
  {
      if (qi < 0 || qi >= _questions.Count) return;
      var q = _questions[qi];
      if (oi < 0 || oi >= q.Options.Count) return;
      q.SelectedIndex = oi;
      q.Answered = true;
      StateHasChanged();
  }

  void ShowScore()
  {
      _scoreVisible = true;
      StateHasChanged();
  }

  void ResetQuiz()
  {
      foreach (var q in _questions)
      {
          q.SelectedIndex = null;
          q.Answered = false;
      }
      _scoreVisible = false;
      StateHasChanged();
  }

  protected override void OnInitialized()
  {
      if (_questions.Count == 0)
      {
          _questions = BuildQuestions();
          // Перемешать варианты ответов у каждого вопроса один раз при инициализации
          foreach (var q in _questions)
          {
              ShuffleOptions(q);
          }
      }
  }

  void ShuffleOptions(QuizQuestion q)
  {
      if (q.Options.Count <= 1) return;
      var n = q.Options.Count;
      // Индексы исходного порядка
      var idx = Enumerable.Range(0, n).ToList();
      // Фишера-Йетса
      for (int i = n - 1; i > 0; i--)
      {
          int j = _rng.Next(i + 1);
          (idx[i], idx[j]) = (idx[j], idx[i]);
      }
      // Собрать новый порядок опций
      var newOptions = new List<string>(n);
      for (int k = 0; k < n; k++) newOptions.Add(q.Options[idx[k]]);
      // Найти новую позицию правильного ответа
      var newCorrect = idx.IndexOf(q.CorrectIndex);
      q.Options = newOptions;
      q.CorrectIndex = newCorrect;
  }

  List<QuizQuestion> BuildQuestions()
  {
      return new List<QuizQuestion>
      {
          Q("Какой атрибут делает класс API контроллером?",
            new[]{"[ApiController]", "[Controller]", "[RestController]"}, 0,
            "[ApiController] включает автоматическую валидацию ModelState и другие удобства."),
          
          Q("Какой HTTP-метод используется для создания ресурса?",
            new[]{"POST", "GET", "PUT"}, 0,
            "POST — стандарт для создания новых ресурсов."),
          
          Q("Что возвращает IActionResult?",
            new[]{"HTTP-ответ", "JSON объект", "Строку"}, 0,
            "IActionResult — интерфейс для различных типов HTTP-ответов (200, 404, 400 и т.д.)."),
          
          Q("Какой порядок middleware правильный?",
            new[]{"Routing → Authentication → Authorization", "Authorization → Authentication → Routing", "Authentication → Routing → Authorization"}, 0,
            "Сначала маршрутизация, затем аутентификация, затем авторизация."),
          
          Q("Что делает [FromBody] атрибут?",
            new[]{"Парсит JSON из тела запроса", "Читает query параметры", "Берет данные из route"}, 0,
            "[FromBody] указывает, что параметр должен быть десериализован из JSON тела запроса."),
          
          Q("Какой код возвращать при успешном создании?",
            new[]{"201 Created", "200 OK", "204 No Content"}, 0,
            "201 Created — стандартный код для успешно созданного ресурса."),
          
          Q("Что такое DTO?",
            new[]{"Data Transfer Object", "Database Transfer Object", "Dynamic Type Object"}, 0,
            "DTO — паттерн для передачи данных между слоями приложения."),
          
          Q("Для чего нужен AsNoTracking()?",
            new[]{"Повышение производительности read-only запросов", "Отключение логирования", "Удаление кэша"}, 0,
            "AsNoTracking отключает отслеживание изменений Entity Framework, ускоряя read-only операции."),

          // Новые вопросы про наш проект
          Q("Какой путь у контроллера Rooms по умолчанию?",
            new[]{"/api/Rooms", "/rooms", "/api/Room"}, 0,
            "[Route(\"api/[controller]\")] → имя контроллера RoomsController даёт путь /api/Rooms."),

          Q("Какие роли могут СОЗДАВАТЬ/ОБНОВЛЯТЬ/УДАЛЯТЬ комнаты?",
            new[]{"Admin, Manager, InfiniteVoid", "Любой авторизованный", "Только Admin"}, 0,
            "В RoomsController на POST/PUT/DELETE стоит [Authorize(Roles = \"Admin,Manager,InfiniteVoid\")]."),

          Q("Что вернёт POST /api/Rooms при успехе?",
            new[]{"201 Created и Location заголовок", "200 OK без тела", "204 No Content"}, 0,
            "Создание комнаты возвращает CreatedAtAction → 201 и ссылку на ресурс."),

          Q("Что вернёт PUT /api/Rooms/{id} при успехе?",
            new[]{"204 No Content", "200 OK с комнатой", "201 Created"}, 0,
            "По коду — NoContent() (без тела)."),

          Q("Максимум дней в /api/Rooms/availability?",
            new[]{"60", "28", "7"}, 0,
            "В контроллере: если days > 60 → берём 60."),

          Q("Без токена к TicketsController…",
            new[]{"Не пустит (401)", "Пустит, но только GET", "Пустит, если есть роль"}, 0,
            "На всём TicketsController — [Authorize]."),

          Q("Если токен есть, но роли не хватает, какой код?",
            new[]{"403 Forbidden", "401 Unauthorized", "404 NotFound"}, 0,
            "Недостаточно прав → 403."),

          Q("Дубликат номера комнаты в одном отеле даёт…",
            new[]{"409 Conflict", "400 BadRequest", "500 Internal"}, 0,
            "Есть уникальный индекс (HotelId, Number) и ловим конфликт — 409."),

          Q("Где в проекте сидят роли по умолчанию?",
            new[]{"AppDBContext.OnModelCreating (HasData)", "appsettings.json", "Blazor Program.cs"}, 0,
            "Роли seed-ятся в AppDBContext через HasData."),

          Q("Что делает [FromQuery] в GetAvailability?",
            new[]{"Берёт значения из строки запроса", "Читает тело запроса", "Бросает исключение"}, 0,
            "Параметры days, hotelId приходят из query (?days=&amp;hotelId=)."),

          Q("Что вернёт GET /api/Rooms/99999 если комнаты нет?",
            new[]{"404 NotFound", "200 OK с пустым объектом", "204 No Content"}, 0,
            "Контроллер явно возвращает NotFound() если запись не найдена."),

          Q("Что использовать, чтобы сказать клиенту ‘всё ок, но тела нет’?",
            new[]{"204 No Content", "201 Created", "409 Conflict"}, 0,
            "Например, после успешного PUT или DELETE."),

          // Доп. вопросы по моделям и безопасности
          Q("Что такое сущность (Entity) в нашем проекте?",
            new[]{"Класс для БД (например, Room, Booking)", "Компонент UI", "Файл настроек"}, 0,
            "Сущность — это модель данных, которая хранится в БД через EF Core."),

          Q("Зачем хранить RefreshToken как TokenHash?",
            new[]{"Чтобы даже из БД нельзя было украсть токен", "Чтобы экономить место", "Чтобы ускорить логин"}, 0,
            "Мы храним только хеш: сравниваем по хешу, сам токен в БД не лежит — безопаснее."),

          Q("Что даёт базовый класс Common?",
            new[]{"Id, CreatedAt, UpdatedAt", "Пароль и Email", "JWT настройки"}, 0,
            "Общие технические поля для всех сущностей."),

          Q("VipRoom — это…",
            new[]{"Наследник Room с VIP-полями", "Отдельный отель", "Роль пользователя"}, 0,
            "VipRoom наследует Room и добавляет сервисы/удобства."),

          Q("Какая связь между Hotel и Room?",
            new[]{"1 отель → много комнат", "Много ко многим", "1 к 1"}, 0,
            "Обычная связь 1:N: у отеля список комнат."),

          Q("Что обязательно содержит TicketMessage?",
            new[]{"TicketId, SenderUserId и Content", "RoomId и Price", "HotelId и Address"}, 0,
            "Это сообщение в тикете: текст и ссылки на тикет и отправителя."),

          Q("Чем RoomReadDto отличается от RoomCreateDto?",
            new[]{"ReadDto содержит Id и вычисленные/доп. поля", "CreateDto всегда длиннее", "Они одинаковые"}, 0,
            "ReadDto — для ответа (включая Id), CreateDto — только то, что нужно на входе."),
      };
  }

  static QuizQuestion Q(string text, string[] options, int correct, string? explanation = null)
  {
      return new QuizQuestion
      {
          Text = text,
          Options = options.ToList(),
          CorrectIndex = correct,
          Explanation = explanation
      };
  }
}
