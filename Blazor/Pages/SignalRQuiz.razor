@page "/signalr-quiz"
@inject IJSRuntime JS

<PageTitle>SignalR — Реальное время (гайд + квиз)</PageTitle>

<link href="css/jwt-learn.css" rel="stylesheet" />

<div class="jwt-page">
  <h1>SignalR — простыми словами + практический квиз</h1>
  <div class="toc">
    <b>Разделы:</b>
    <a @onclick="@(() => ScrollToSection("idea"))" style="cursor: pointer;">Идея</a>
    <a @onclick="@(() => ScrollToSection("map"))" style="cursor: pointer;">Карта в проекте</a>
    <a @onclick="@(() => ScrollToSection("server"))" style="cursor: pointer;">Сервер (Hub)</a>
    <a @onclick="@(() => ScrollToSection("client"))" style="cursor: pointer;">Клиент (Blazor)</a>
    <a @onclick="@(() => ScrollToSection("auth"))" style="cursor: pointer;">JWT и подключение</a>
    <a @onclick="@(() => ScrollToSection("quiz"))" style="cursor: pointer;">Финальный квиз</a>
  </div>

  <h2 id="idea">Главная идея</h2>
  <div class="callout info">
    <div class="title">Почему SignalR?</div>
    <p>SignalR поддерживает постоянное соединение между браузером и сервером. Сервер может сам «толкать» события клиентам: чаты, уведомления, дашборды — всё без опросов.</p>
  </div>

  <h2 id="map">Карта в нашем проекте</h2>
  <ul>
    <li><b><code>API/Program.cs</code></b> — включаем сервисы и мапим хаб: <code>app.MapHub&lt;TicketHub&gt;("/hubs/tickets")</code>.</li>
    <li><b><code>API/Hubs/TicketHub.cs</code></b> — сам хаб: группы <code>role-...</code>, <code>admins</code>, <code>ticket-{id}</code>.</li>
    <li><b><code>API/Controllers/TicketsController.cs</code></b> — после создания тикета рассылает <code>TicketCreated</code> в нужную группу через <code>IHubContext</code>.</li>
    <li><b><code>Blazor/Services/TicketHubClient.cs</code></b> — клиентский <code>HubConnection</code>, <code>.On(...)</code> и <code>.InvokeAsync(...)</code>.</li>
  </ul>

  <h2 id="server">Сервер (Hub) — группы и события</h2>
  <ul>
    <li>Подключение: <code>OnConnectedAsync</code>, подписываем в <code>role-{Role}</code>, для Admin/Manager ещё и <code>admins</code>.</li>
    <li>Адрес хаба: <code>/hubs/tickets</code>.</li>
    <li>Группы: целевая доставка через <code>Clients.Group("...").SendAsync(...)</code>.</li>
  </ul>

  <h2 id="client">Клиент (Blazor)</h2>
  <ul>
    <li><code>HubConnectionBuilder().WithUrl(...).WithAutomaticReconnect().Build()</code></li>
    <li>Обработчики: <code>hubConnection.On&lt;T&gt;("EventName", handler)</code></li>
    <li>Вызовы на сервер: <code>hubConnection.InvokeAsync("Method", args...)</code></li>
  </ul>

  <h2 id="auth">JWT и подключение к хабу</h2>
  <div class="callout info">
    <div class="title">Тонкость с токеном</div>
    <div>
      <ul>
        <li>Для WebSocket токен передаём в URL через <code>AccessTokenProvider</code> → <code>?access_token=...</code>.</li>
        <li>На сервере в <code>AddJwtBearer</code> используем <b>OnMessageReceived</b>, чтобы брать токен из query string, если путь начинается с <code>/hubs</code>.</li>
      </ul>
    </div>
  </div>

  <h2 id="quiz">Финальный КВИЗ RU/DA</h2>
  <p>Нажимай на варианты — сразу увидишь «Верно/Неверно». Ответы перемешаны.</p>
  <div class="quiz">
    @for (int i = 0; i < _questions.Count; i++)
    {
        var questionIndex = i;
        var q = _questions[questionIndex];
        <div class="q">
          <div class="qtext"><b>@(questionIndex+1).</b> @q.Text</div>
          <div class="opts">
            @for (int j = 0; j < q.Options.Count; j++)
            {
                var optionIndex = j;
                var opt = q.Options[optionIndex];
                var chosen = q.SelectedIndex == optionIndex;
                var cls = q.Answered
                    ? (optionIndex == q.CorrectIndex ? "opt correct" : (chosen ? "opt wrong" : "opt"))
                    : (chosen ? "opt chosen" : "opt");
                <button class="@cls" type="button" @onclick="@(() => SelectAnswer(questionIndex, optionIndex))" disabled="@q.Answered">@opt</button>
            }
          </div>
          @if (q.Answered)
          {
            var isCorrect = q.SelectedIndex == q.CorrectIndex;
            <div class="feedback @(isCorrect ? "correct" : "wrong")">
                @(isCorrect ? "Верно! / Korrekt!" : "Неверно. / Forkert.")
            </div>
            @if (!string.IsNullOrWhiteSpace(q.Explanation))
            {
              <div class="explain"><b>Пояснение:</b> @q.Explanation</div>
            }
          }
        </div>
    }
    <div class="quiz-actions">
      <button class="btn" type="button" @onclick="ShowScore">Показать результат</button>
      <button class="btn ghost" type="button" @onclick="ResetQuiz">Сбросить</button>
    </div>
    @if (_scoreVisible)
    {
      <div class="score">Результат: <b>@CorrectCount</b> из <b>@_questions.Count</b> — @(ScoreComment)</div>
    }
  </div>

  <div class="nav-buttons">
    <a href="/" class="btn">На главную</a>
  </div>
</div>

@code {
  private async Task ScrollToSection(string sectionId)
  {
      try
      {
          await JS.InvokeVoidAsync("eval", $"document.getElementById('{sectionId}')?.scrollIntoView({{ behavior: 'smooth', block: 'start' }});");
      }
      catch (Exception ex)
      {
          Console.WriteLine($"[SCROLL] Error: {ex.Message}");
      }
  }

  class QuizQuestion
  {
      public string Text { get; set; } = string.Empty;
      public List<string> Options { get; set; } = new();
      public int CorrectIndex { get; set; }
      public string? Explanation { get; set; }
      public int? SelectedIndex { get; set; }
      public bool Answered { get; set; }
  }

  private List<QuizQuestion> _questions = new();
  private bool _scoreVisible;
  private static readonly Random _rng = new Random();
  
  int CorrectCount => _questions.Count(q => q.Answered && q.SelectedIndex == q.CorrectIndex);
  string ScoreComment => CorrectCount switch
  {
      >= 10 => "Магистр SignalR! / SignalR Mester! ⚡",
      >= 8 => "Эксперт реального времени / Realtidsekspert 👍",
      >= 5 => "Уверенный пользователь / Sikker bruger 🙂",
      _ => "Стоит перечитать / Bør læses igen 📚"
  };

  void SelectAnswer(int qi, int oi)
  {
      if (qi < 0 || qi >= _questions.Count) return;
      var q = _questions[qi];
      if (oi < 0 || oi >= q.Options.Count) return;
      q.SelectedIndex = oi;
      q.Answered = true;
      StateHasChanged();
  }

  void ShowScore()
  {
      _scoreVisible = true;
      StateHasChanged();
  }

  void ResetQuiz()
  {
      _questions = BuildQuestions();
      _scoreVisible = false;
      StateHasChanged();
  }

  protected override void OnInitialized()
  {
      if (_questions.Count == 0)
      {
          _questions = BuildQuestions();
      }
  }

  List<QuizQuestion> BuildQuestions()
  {
      return new List<QuizQuestion>
      {
          Q("Что такое SignalR? / Hvad er SignalR?",
            new[]{"Технология для real-time связи (рация) / Teknologi til realtidskommunikation (walkie-talkie)","База данных / En database","Система для рисования графиков / Et system til at tegne grafer", "Новый язык программирования / Et nyt programmeringssprog"}, 0,
            "SignalR создаёт постоянное соединение, позволяя серверу отправлять данные клиенту в любой момент."),

          Q("От какого класса наследуется SignalR Hub? / Hvilken klasse nedarver en SignalR Hub fra?",
            new[]{"Hub", "Controller", "MiddlewareBase", "SignalRService"}, 0,
            "Hub — базовый класс для серверного хаба в ASP.NET Core SignalR."),

          Q("Как в нашем проекте клиент передаёт JWT-токен для авторизации в хабе? / Hvordan sender klienten JWT-token til hub'en?",
            new[]{"Через параметр в URL (?access_token=...) / Via en URL-parameter (?access_token=...)","В HTTP-заголовке Authorization / I Authorization-headeren","В cookie-файле / I en cookie", "Он не передаётся / Det sendes ikke"}, 0,
            "Для WebSocket заголовок Authorization недоступен напрямую, поэтому используем query string."),

          Q("Что делает Clients.Group(\"some-group\").SendAsync(...)? / Hvad gør Clients.Group(\"some-group\").SendAsync(...)?",
            new[]{"Отправляет сообщение всем клиентам в группе 'some-group'","Отправляет сообщение всем клиентам, кроме 'some-group'","Создаёт новую группу","Отправляет одному случайному клиенту"}, 0,
            "Это таргетированная рассылка по группе."),

          Q("Какой метод на клиенте настраивает реакцию на сигнал от сервера? / Hvilken metode på klienten registrerer en handler?",
            new[]{"hubConnection.On()","hubConnection.InvokeAsync()","hubConnection.SendAsync()","hubConnection.StartAsync()"}, 0,
            "On регистрирует обработчик входящих событий."),

          Q("В какой момент пользователь попадает в группу ticket-{id}? / Hvornår tilføjes brugeren til gruppen ticket-{id}?",
            new[]{"Когда вызывает метод JoinTicket(id)","Сразу после подключения","Когда пишет первое сообщение","Никогда"}, 0,
            "Нужно явно вызвать JoinTicket на хабе."),

          Q("Зачем в API/Program.cs нужна настройка OnMessageReceived для JWT? / Hvorfor OnMessageReceived i API/Program.cs?",
            new[]{"Чтобы искать токен в URL для SignalR","Чтобы шифровать токен","Чтобы генерировать новые токены","Это для обычных HTTP-запросов"}, 0,
            "Адаптируем аутентификацию под специфику SignalR."),

          Q("Что делает hubConnection.InvokeAsync(\"MyMethod\", ...)? / Hvad gør hubConnection.InvokeAsync(\"MyMethod\", ...)?",
            new[]{"Вызывает метод на серверном хабе","Ждёт вызова от сервера","Отключается от сервера","Обновляет страницу"}, 0,
            "InvokeAsync — вызов метода на сервере со стороны клиента."),

          Q("Кто отправляет уведомление TicketCreated в группу role-{RoleName}? / Hvem sender TicketCreated til role-{RoleName}?",
            new[]{"TicketsController после создания тикета","Клиент, создавший тикет","TicketHub при подключении нового пользователя","Никто"}, 0,
            "REST-контроллер использует IHubContext для рассылки после операций."),

          Q("Что делает .WithAutomaticReconnect()? / Hvad gør .WithAutomaticReconnect()?",
            new[]{"Пытается автоматически восстановить соединение","Ускоряет доставку сообщений","Включает шифрование","Ничего не делает"}, 0,
            "Автовосстановление соединения повышает стабильность."),

          Q("Какое событие рассылается при новом сообщении в тикете? / Hvilken event sendes ved ny besked i en ticket?",
            new[]{"NewMessage","TicketCreated","toast","TicketClosed"}, 0,
            "Hub шлёт Clients.Group(\"ticket-{id}\").SendAsync(\"NewMessage\", ...)."),

          Q("Какой маршрут у нашего хаба тикетов? / Hvilken rute bruger ticket-hubben?",
            new[]{"/hubs/tickets","/api/tickets","/hubs/chat","/signalr"}, 0,
            "В Program.cs: app.MapHub<TicketHub>(\"/hubs/tickets\")."),

          Q("В какую группу попадёт сотрудник роли Manager при подключении? / Hvilke grupper får Manager?",
            new[]{"role-Manager и admins","admins только","ticket-*","Никуда"}, 0,
            "OnConnectedAsync подписывает в role-{Role}, а для Admin/Manager — ещё и в admins."),
      };
  }

  static QuizQuestion Q(string text, string[] options, int correct, string? explanation = null)
  {
      var opts = options.ToList();
      if (opts.Count == 0) throw new ArgumentException("Options must not be empty");
      if (correct < 0 || correct >= opts.Count) throw new ArgumentOutOfRangeException(nameof(correct));

      var correctValue = opts[correct];

      // Fisher–Yates shuffle
      for (int i = opts.Count - 1; i > 0; i--)
      {
          int j = _rng.Next(i + 1);
          (opts[i], opts[j]) = (opts[j], opts[i]);
      }

      var newCorrectIndex = opts.FindIndex(o => string.Equals(o, correctValue, StringComparison.Ordinal));
      if (newCorrectIndex < 0) newCorrectIndex = 0; // на случай дубликатов

      return new QuizQuestion
      {
          Text = text,
          Options = opts,
          CorrectIndex = newCorrectIndex,
          Explanation = explanation
      };
  }
}
