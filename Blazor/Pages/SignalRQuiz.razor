@page "/signalr-quiz"
@inject IJSRuntime JS

<PageTitle>SignalR Quiz</PageTitle>

<link href="css/jwt-learn.css" rel="stylesheet" />

<div class="jwt-page">
  <h1>SignalR Quiz — Real-time коммуникации</h1>
  <p>
    Тестируй знания по SignalR — технологии для двунаправленной коммуникации между клиентом и сервером в реальном времени.
  </p>

  <div class="toc">
    <b>Разделы:</b>
    <a @onclick="@(() => ScrollToSection("map"))" style="cursor: pointer;">Карта проекта</a>
    <a @onclick="@(() => ScrollToSection("basics"))" style="cursor: pointer;">Основы SignalR</a>
    <a @onclick="@(() => ScrollToSection("server"))" style="cursor: pointer;">Сервер (Hub)</a>
    <a @onclick="@(() => ScrollToSection("client"))" style="cursor: pointer;">Клиент (Blazor)</a>
    <a @onclick="@(() => ScrollToSection("groups"))" style="cursor: pointer;">Группы и broadcast</a>
    <a @onclick="@(() => ScrollToSection("auth"))" style="cursor: pointer;">Аутентификация</a>
    <a @onclick="@(() => ScrollToSection("flow"))" style="cursor: pointer;">Как всё работает вместе</a>
    <a @onclick="@(() => ScrollToSection("faq"))" style="cursor: pointer;">FAQ/Ошибки</a>
    <a @onclick="@(() => ScrollToSection("quiz"))" style="cursor: pointer;">Финальный квиз</a>
  </div>

  <h2 id="map">Карта проекта (где живёт SignalR)</h2>
  <ul>
    <li><code>API/Program.cs</code> — включаем <b>AddSignalR()</b>, настраиваем JWT для хаба, CORS с <b>AllowCredentials()</b>, мапим маршрут: <code>app.MapHub&lt;TicketHub&gt;("/hubs/tickets")</code>.</li>
    <li><code>API/Hubs/TicketHub.cs</code> — наш <b>Hub</b> с группами: <code>role-{RoleName}</code>, <code>admins</code>, <code>ticket-{id}</code>, методами <b>JoinTicket</b>/<b>LeaveTicket</b>/<b>SendMessage</b>.</li>
    <li><code>API/Controllers/TicketsController.cs</code> — REST-часть, рассылает события в Hub: <code>TicketCreated</code>, <code>TicketUpdated</code>, <code>toast</code>.</li>
    <li><code>Blazor/Services/TicketHubClient.cs</code> — клиент: строит <b>HubConnection</b>, отдаёт токен через <b>AccessTokenProvider</b>, слушает события, вызывает методы.</li>
  </ul>

  <h2 id="basics">Основы SignalR</h2>
  <p>SignalR — библиотека для real-time. Сервер шлёт события, клиенты принимают мгновенно.</p>
  <ul>
    <li>Транспорты: WebSockets (лучше), SSE, Long Polling — выбор автоматом.</li>
    <li>Двусторонняя связь: клиент → сервер (вызовы методов), сервер → клиент (события).</li>
    <li>Группы — удобно слать не всем, а нужным пользователям.</li>
  </ul>

  <h2 id="server">Сервер: наш TicketHub</h2>
  <ul>
    <li><b>Маршрут:</b> <code>/hubs/tickets</code> (см. <code>Program.cs</code>).</li>
    <li><b>[Authorize]</b> на Hub — подключаться могут только с валидным JWT.</li>
    <li><b>OnConnectedAsync</b>: подписывает по роли в <code>role-{Role}</code> и, если Admin/Manager, в <code>admins</code>.</li>
    <li><b>JoinTicket(id)</b> — добавляет соединение в группу <code>ticket-{id}</code> (после простой проверки доступа).</li>
    <li><b>SendMessage(id, text)</b> — пишет в БД сообщение и шлёт событие <code>NewMessage</code> в группу <code>ticket-{id}</code>.</li>
  </ul>
  <div class="callout info">
    <div class="title">JWT в SignalR</div>
    <div>В <code>Program.cs</code> настроено: JWT берём из query <code>?access_token=...</code> ТОЛЬКО для пути <code>/hubs/tickets</code> (см. <code>OnMessageReceived</code> в <b>AddJwtBearer</b>).</div>
  </div>

  <h2 id="client">Клиент Blazor: TicketHubClient</h2>
  <ul>
    <li>Создаёт <b>HubConnection</b> с <code>.WithUrl(base/hubs/tickets)</code>.</li>
    <li><b>AccessTokenProvider</b> — отдаёт <code>access_token</code> (достаём из APIService).</li>
    <li><b>WithAutomaticReconnect()</b> — пытается переподключаться сам.</li>
    <li>Подписки на события:
      <ul>
        <li><code>TicketCreated</code> — для роли (новые тикеты).</li>
        <li><code>TicketUpdated</code> — когда тикет меняется.</li>
        <li><code>NewMessage</code> — новые сообщения в чате тикета.</li>
        <li><code>toast</code> — уведомления для админки.</li>
      </ul>
    </li>
    <li>Вызываемые методы: <code>JoinTicket</code>, <code>LeaveTicket</code>, <code>SendMessage</code>.</li>
  </ul>

  <h2 id="groups">Группы и broadcast</h2>
  <p>Кого куда подписываем:</p>
  <ul>
    <li><b>role-{RoleName}</b> — всем сотрудникам роли (получают новые тикеты).</li>
    <li><b>admins</b> — админы и менеджеры (получают «тосты»).</li>
    <li><b>ticket-{id}</b> — участники конкретного тикета (создатель, исполнитель, роль).</li>
  </ul>
  <p>REST-контроллеры тоже пушат: при создании/назначении/изменении статуса — Hub оповещает группы.</p>

  <h2 id="auth">Аутентификация</h2>
  <ul>
    <li>Hub защищён <b>[Authorize]</b>.</li>
    <li>Клиент передаёт токен: <code>AccessTokenProvider → ?access_token=...</code>.</li>
    <li>CORS разрешён для наших доменов, включено <b>AllowCredentials()</b> — иначе браузер не пустит WebSocket с куками/заголовками.</li>
  </ul>

  <h2 id="flow">Как всё работает вместе (жизненный цикл)</h2>
  <ol>
    <li>Пользователь логинится → получает <code>access_token</code>.</li>
    <li>Blazor создаёт <b>HubConnection</b>, подставляет токен, подключается к <code>/hubs/tickets</code>.</li>
    <li>Hub кладёт соединение в группы по роли (<code>role-*</code>, <code>admins</code>).</li>
    <li>Пользователь открывает тикет → клиент вызывает <code>JoinTicket(id)</code> → попадает в <code>ticket-{id}</code>.</li>
    <li>Кто-то пишет сообщение → сервер шлёт <code>NewMessage</code> в группу <code>ticket-{id}</code> — все сразу видят.</li>
    <li>Создан новый тикет → сервер шлёт <code>TicketCreated</code> в <code>role-{TargetRole}</code> и тост в <code>admins</code>.</li>
  </ol>

  <h2 id="faq">FAQ и типовые ошибки</h2>
  <ul>
    <li><b>401/не подключается</b> — нет валидного токена. Проверь логин и <code>AccessTokenProvider</code>.</li>
    <li><b>403 в JoinTicket</b> — нет доступа к тикету (не создатель, не исполнитель, не нужная роль).</li>
    <li><b>CORS ругается</b> — домен не в списке <code>WithOrigins(...)</code> или выключены <code>AllowCredentials()</code>.</li>
    <li><b>События не приходят</b> — не вступили в группу: вызови <code>JoinTicket(id)</code>, проверь обработчики <code>_conn.On(...)</code>.</li>
  </ul>

  <h2 id="quiz">Финальный квиз</h2>
  <p>Покажи свои знания SignalR!</p>
  <div class="quiz">
    @for (int i = 0; i < _questions.Count; i++)
    {
        var questionIndex = i;
        var q = _questions[questionIndex];
        <div class="q">
          <div class="qtext"><b>@(questionIndex+1).</b> @q.Text</div>
          <div class="opts">
            @for (int j = 0; j < q.Options.Count; j++)
            {
                var optionIndex = j;
                var opt = q.Options[optionIndex];
                var chosen = q.SelectedIndex == optionIndex;
                var cls = q.Answered
                    ? (optionIndex == q.CorrectIndex ? "opt correct" : (chosen ? "opt wrong" : "opt"))
                    : (chosen ? "opt chosen" : "opt");
                <button class="@cls" type="button" @onclick="@(() => SelectAnswer(questionIndex, optionIndex))" disabled="@q.Answered">@opt</button>
            }
          </div>
          @if (q.Answered)
          {
            var isCorrect = q.SelectedIndex == q.CorrectIndex;
            <div class="feedback @(isCorrect ? "correct" : "wrong")">
                @(isCorrect ? "Верно! ✓" : "Неверно. ✗")
            </div>
            @if (!string.IsNullOrWhiteSpace(q.Explanation))
            {
              <div class="explain"><b>Объяснение:</b> @q.Explanation</div>
            }
          }
        </div>
    }
    <div class="quiz-actions">
      <button class="btn" type="button" @onclick="ShowScore">Показать результат</button>
      <button class="btn ghost" type="button" @onclick="ResetQuiz">Сбросить</button>
    </div>
    @if (_scoreVisible)
    {
      <div class="score">Результат: <b>@CorrectCount</b> из <b>@_questions.Count</b> — @(ScoreComment)</div>
    }
  </div>

  <div class="nav-buttons">
    <a href="/" class="btn">На главную</a>
  </div>
</div>

@code {
  private async Task ScrollToSection(string sectionId)
  {
      try
      {
          await JS.InvokeVoidAsync("eval", $"document.getElementById('{sectionId}')?.scrollIntoView({{ behavior: 'smooth', block: 'start' }});");
      }
      catch (Exception ex)
      {
          Console.WriteLine($"[SCROLL] Error: {ex.Message}");
      }
  }

  class QuizQuestion
  {
      public string Text { get; set; } = string.Empty;
      public List<string> Options { get; set; } = new();
      public int CorrectIndex { get; set; }
      public string? Explanation { get; set; }
      public int? SelectedIndex { get; set; }
      public bool Answered { get; set; }
  }

  private List<QuizQuestion> _questions = new();
  private bool _scoreVisible;
  private readonly Random _rng = new Random();
  
  int CorrectCount => _questions.Count(q => q.Answered && q.SelectedIndex == q.CorrectIndex);
  string ScoreComment => CorrectCount switch
  {
      >= 10 => "SignalR профи! ⚡",
      >= 7 => "Отлично! 👍",
      >= 5 => "Хорошо! 🙂",
      _ => "Повтори материал 📚"
  };

  void SelectAnswer(int qi, int oi)
  {
      if (qi < 0 || qi >= _questions.Count) return;
      var q = _questions[qi];
      if (oi < 0 || oi >= q.Options.Count) return;
      q.SelectedIndex = oi;
      q.Answered = true;
      StateHasChanged();
  }

  void ShowScore()
  {
      _scoreVisible = true;
      StateHasChanged();
  }

  void ResetQuiz()
  {
      foreach (var q in _questions)
      {
          q.SelectedIndex = null;
          q.Answered = false;
      }
      _scoreVisible = false;
      StateHasChanged();
  }

  protected override void OnInitialized()
  {
      if (_questions.Count == 0)
      {
          _questions = BuildQuestions();
          // Перемешаем варианты ответов один раз при инициализации
          foreach (var q in _questions)
          {
              ShuffleOptions(q);
          }
      }
  }

  void ShuffleOptions(QuizQuestion q)
  {
      if (q.Options.Count <= 1) return;
      var n = q.Options.Count;
      var idx = Enumerable.Range(0, n).ToList();
      for (int i = n - 1; i > 0; i--)
      {
          int j = _rng.Next(i + 1);
          (idx[i], idx[j]) = (idx[j], idx[i]);
      }
      var newOptions = new List<string>(n);
      for (int k = 0; k < n; k++) newOptions.Add(q.Options[idx[k]]);
      var newCorrect = idx.IndexOf(q.CorrectIndex);
      q.Options = newOptions;
      q.CorrectIndex = newCorrect;
  }

  List<QuizQuestion> BuildQuestions()
  {
      return new List<QuizQuestion>
      {
          Q("От какого класса наследуется SignalR Hub?",
            new[]{"Hub или Hub<T>", "Controller", "MiddlewareBase"}, 0,
            "Hub — базовый класс для создания SignalR хабов."),
          
          Q("Какой транспорт предпочтительнее для SignalR?",
            new[]{"WebSockets", "Long Polling", "Server-Sent Events"}, 0,
            "WebSockets обеспечивают самую низкую задержку и двунаправленную связь."),
          
          Q("Как отправить сообщение всем клиентам?",
            new[]{"Clients.All.SendAsync()", "Clients.Send()", "Broadcast.All()"}, 0,
            "Clients.All отправляет сообщение всем подключенным клиентам."),
          
          Q("Как передать JWT токен в SignalR?",
            new[]{"Через query string в URL подключения", "В HTTP заголовке", "В теле сообщения"}, 0,
            "В нашем проекте OnMessageReceived читает ?access_token=... для пути /hubs/tickets."),
          
          Q("Что такое ConnectionId?",
            new[]{"Уникальный ID подключения клиента", "ID пользователя", "ID группы"}, 0,
            "Каждое подключение получает уникальный ConnectionId."),
          
          Q("Как добавить клиента в группу?",
            new[]{"Groups.AddToGroupAsync()", "Clients.AddGroup()", "Hub.JoinGroup()"}, 0,
            "Groups.AddToGroupAsync добавляет текущее подключение в указанную группу."),
          
          Q("Что делает Clients.Caller?",
            new[]{"Отправляет только вызывающему клиенту", "Отправляет всем", "Отправляет кроме вызывающего"}, 0,
            "Clients.Caller отправляет сообщение только инициатору вызова."),
          
          Q("Можно ли использовать [Authorize] на Hub?",
            new[]{"Да, для защиты всех методов Hub", "Нет, только на контроллерах", "Да, но бесполезно"}, 0,
            "[Authorize] на Hub защищает методы от неавторизованного доступа."),

          // Про наш проект
          Q("Какой маршрут у нашего хаба тикетов?",
            new[]{"/hubs/tickets", "/api/tickets", "/hubs/chat"}, 0,
            "В Program.cs: app.MapHub<TicketHub>(\"/hubs/tickets\")."),

          Q("Как клиент Blazor передаёт access_token в Hub?",
            new[]{"AccessTokenProvider → ?access_token=...", "Через cookie", "В POST теле"}, 0,
            "TicketHubClient использует WithUrl(..., options.AccessTokenProvider = ...)."),

          Q("В какую группу попадёт сотрудник роли Manager при подключении?",
            new[]{"role-Manager и admins", "admins только", "ticket-*"}, 0,
            "OnConnectedAsync подписывает в role-{Role} и, если Admin/Manager, ещё и в admins."),

          Q("Как подписаться на сообщения конкретного тикета?",
            new[]{"Вызвать JoinTicket(id)", "Позвонить в REST", "Это автоматически"}, 0,
            "Нужно явно вызвать JoinTicket, чтобы попасть в группу ticket-{id}."),

          Q("Какое событие рассылается при новом сообщении в тикете?",
            new[]{"NewMessage", "TicketCreated", "toast"}, 0,
            "Hub шлёт Clients.Group(\"ticket-{id}\").SendAsync(\"NewMessage\", ...)."),

          Q("Куда шлётся событие о создании тикета по роли?",
            new[]{"В группу role-{TargetRole}", "Только создателю тикета", "Всем пользователям"}, 0,
            "REST-контроллер шлёт TicketCreated в группу role-{Role}."),

          Q("Зачем нужен AllowCredentials() в CORS для SignalR?",
            new[]{"Чтобы позволить куки/заголовки при WebSocket", "Чтобы включить HTTP/2", "Чтобы разрешить любые домены"}, 0,
            "Без этого браузер может блокировать аутентифицированное соединение."),

          Q("Что сделает WithAutomaticReconnect()?",
            new[]{"Попробует переподключиться", "Ускорит сообщения", "Ничего не меняет"}, 0,
            "Клиент переподключится при кратковременном обрыве."),
      };
  }

  static QuizQuestion Q(string text, string[] options, int correct, string? explanation = null)
  {
      return new QuizQuestion
      {
          Text = text,
          Options = options.ToList(),
          CorrectIndex = correct,
          Explanation = explanation
      };
  }
}
