@page "/jwt-learn"
@using System.Text
@using System.Text.Json
@using System.Security.Cryptography
@inject IJSRuntime JS

<PageTitle>JWT Learn — Приручи токены</PageTitle>

<link href="css/jwt-learn.css" rel="stylesheet" />

<div class="jwt-page">
  <h1>JWT Learn — Игра «Приручи токены»</h1>
  <p>
    Добро пожаловать на практическую лекцию-игру по JWT. Объясняем «как для друга», но технически «как в книжке». Много примеров, куда что вставлять, и интерактив.
    К концу урока ты сможешь: собрать свой JWT, авторизоваться в API, обновить/отозвать токены и победить финальный квиз.
  </p>

  <div class="toc">
    <b>Карта уровней:</b>
    <a @onclick="@(() => ScrollToSection("lvl1"))" style="cursor: pointer;">Уровень 1. Что такое JWT</a>
    <a @onclick="@(() => ScrollToSection("lvl2"))" style="cursor: pointer;">Уровень 2. Сервер: как настраивается</a>
    <a @onclick="@(() => ScrollToSection("lvl3"))" style="cursor: pointer;">Уровень 3. Клиент Blazor: как пользуемся</a>
    <a @onclick="@(() => ScrollToSection("lvl4"))" style="cursor: pointer;">Уровень 4. Active Directory вход</a>
    <a @onclick="@(() => ScrollToSection("lvl5"))" style="cursor: pointer;">Уровень 5. Refresh & Rotation</a>
    <a @onclick="@(() => ScrollToSection("lvl6"))" style="cursor: pointer;">Уровень 6. Безопасность</a>
    <a @onclick="@(() => ScrollToSection("lab"))" style="cursor: pointer;">Лаборатория: Собери свой токен</a>
    <a @onclick="@(() => ScrollToSection("http"))" style="cursor: pointer;">HTTP кулинария</a>
    <a @onclick="@(() => ScrollToSection("guide"))" style="cursor: pointer;">Справочник</a>
    <a @onclick="@(() => ScrollToSection("lifecycle"))" style="cursor: pointer;">Жизненный цикл</a>
    <a @onclick="@(() => ScrollToSection("quiz"))" style="cursor: pointer;">Финальный КВИЗ RU/DA</a>
  </div>

  <h2 id="lvl1">Уровень 1. Что такое JWT</h2>
  <ul>
    <li>JWT (JSON Web Token) — это подписью защищённая «визитка» пользователя. Представьте, что это ваш цифровой паспорт или пропуск, который вы показываете на входе.</li>
    <li>Состоит из трёх частей через точки: <b>header.payload.signature</b>. Каждая часть закодирована в формате <a href="https://ru.wikipedia.org/wiki/Base64" target="_blank">Base64Url</a>.</li>
    <li><b>Header (Заголовок)</b> — JSON, где указан тип токена ("JWT") и алгоритм подписи (например, <code>HS256</code> — HMAC с использованием SHA-256).</li>
    <li><b>Payload (Полезная нагрузка)</b> — JSON с утверждениями (<b>claims</b>): кто вы (<code>sub</code>), роль (<code>role</code>), когда выдан (<code>iat</code>), до какого времени действителен (<code>exp</code>).</li>
    <li><b>Signature (Подпись)</b> — цифровая подпись, созданная с помощью секретного ключа, известного только серверу. Она гарантирует, что данные не были изменены после выдачи.</li>
    <li>Токен не шифрован. Содержимое можно прочитать (Base64Url), но нельзя незаметно подменить из-за подписи.</li>
  </ul>

  <h2 id="lvl2">Уровень 2. Сервер: как настраивается</h2>
  <p>Где в проекте это живёт:</p>
  <ul>
    <li>Конфигурация JWT и аутентификация: <code>API/Program.cs</code> — <b>AddAuthentication</b> + <b>AddJwtBearer</b>.</li>
    <li>Генерация токена и refresh: <code>API/Services/JwtService.cs</code>.</li>
    <li>Эндпоинты: логин/refresh/revoke: <code>API/Controllers/AuthController.cs</code>.</li>
  </ul>

  <h3>Ключевые места (образцы из проекта)</h3>
  <p><b>Program.cs</b> — подключение JWT аутентификации (Issuer/Audience/Secret, строгое время жизни):</p>
  <pre>
// API/Program.cs — внутри Program.Main
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ClockSkew = TimeSpan.Zero,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:SecretKey"]))
        };
    });
  </pre>

  <p><b>JwtService.cs</b> — как сервер собирает claims и подписывает токен:</p>
  <pre>
// API/Services/JwtService.cs — GenerateToken(User user, roleName)
var claims = new[]
{
    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
    new Claim(ClaimTypes.Email, user.Email),
    new Claim(ClaimTypes.Role, roleName),
    new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
    new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
    new Claim(JwtRegisteredClaimNames.Iat, nowUnixSeconds, ClaimValueTypes.Integer64)
};
// Дальше — подпись HS256 и срок действия
  </pre>

  <p><b>Authorize</b> на экшенах/контроллерах — главный страж API:</p>
  <pre>
// Пример: закрываем эндпоинт для всех, кроме авторизованных
[Authorize]
[HttpGet("api/tickets/mine")]
public IActionResult GetMyTickets() { ... }

// Только для роли Admin. Если зайдёт кто-то другой — получит 403 Forbidden.
[Authorize(Roles = "Admin")]
public IActionResult SecretForAdmins() { ... }
  </pre>

  <h2 id="lvl3">Уровень 3. Клиент Blazor: как пользуемся</h2>
  <ul>
    <li>Логин кладёт токены в <code>localStorage</code>: <code>access_token</code> и <code>refresh_token</code>.</li>
    <li>Каждый запрос отправляется с <code>Authorization: Bearer &lt;access&gt;</code>.</li>
    <li>Если прилетает 401 — срабатывает автообновление через <b>TryWithTokenRefresh</b>.</li>
  </ul>

  <p><b>Login (с сохранением обоих токенов)</b> — см. <code>Blazor/Services/APIService.Auth.cs</code>:</p>
  <pre>
var response = await _httpClient.PostAsJsonAsync("api/Auth/login", user);
var result = await response.Content.ReadFromJsonAsync&lt;AuthResponseDto&gt;();
await _js.InvokeVoidAsync("localStorage.setItem", "access_token", result.AccessToken);
await SaveRefreshToken(result.RefreshToken);
  </pre>

  <p><b>Автообновление</b> — см. <code>Blazor/Services/APIService.TokenRefresh.cs</code>:</p>
  <pre>
var response = await request();
if (response.StatusCode == HttpStatusCode.Unauthorized)
{
    var refreshed = await RefreshAccessToken();
    if (refreshed) return await request();
}
return response;
  </pre>

  <p><b>Пример использования</b> (Tickets API):</p>
  <pre>
var res = await TryWithTokenRefresh(() => _httpClient.GetAsync("api/tickets/mine"));
res.EnsureSuccessStatusCode();
var tickets = await res.Content.ReadFromJsonAsync&lt;List&lt;TicketRead&gt;&gt;();
  </pre>

  <h2 id="lvl4">Уровень 4. Active Directory вход</h2>
  <ul>
    <li>Эндпоинт: <code>POST api/adauth/login</code> — сервер проверяет учетные данные в AD, мапит группы в роли, выдаёт пару токенов.</li>
    <li>Технически всё остальное (claims, refresh, revoke) — дальше как при обычном логине.</li>
  </ul>

  <h2 id="lvl5">Уровень 5. Refresh & Rotation</h2>
  <ul>
    <li><b>Refresh-токен</b> — это долгоживущий "ключ", который нужен только для одного: получить новый `access_token`, когда старый истечёт.</li>
    <li>На сервере в базе данных хранится только <b>хеш</b> refresh-токена. Оригинал — только у клиента.</li>
    <li>На одного пользователя может быть до 5 активных refresh-токенов (например, с разных устройств). При входе шестого — самый старый автоматически отзывается.</li>
    <li><b>Ротация (Rotation)</b>: при обновлении старый refresh-токен сразу помечается как использованный (<b>revoked</b>), а клиенту выдаётся новая пара access + refresh.</li>
    <li>Если злоумышленник украл refresh-токен и пытается его использовать после ротации, сервер обнаружит reuse и <b>отзовёт все активные токены</b> пользователя.</li>
  </ul>

  <p><b>Схема обновления</b> (упрощённый фрагмент из <code>API/Controllers/AuthController.cs</code>):</p>
  <pre>
// 1. Находим refresh-токен в БД по хешу, проверяем, что он активен.
var refreshToken = await _context.RefreshTokens.SingleOrDefaultAsync(rt => rt.TokenHash == hashedToken);
if (refreshToken == null || refreshToken.IsRevoked)
{
    // Если токен не найден или отозван — возможно, это атака.
    // Отзываем ВСЕ токены пользователя.
    return Unauthorized("Invalid token or reuse detected.");
}

// 2. Отзываем старый токен (IsRevoked = true).
refreshToken.IsRevoked = true;

// 3. Генерируем новую пару access + refresh, сохраняем новый refresh в БД.
var newAccessToken = _jwtService.GenerateToken(user, role);
var newRefreshToken = _jwtService.GenerateRefreshToken();
_context.RefreshTokens.Add(new RefreshToken { /* ... */ });
await _context.SaveChangesAsync();

// 4. Отправляем новую пару токенов клиенту.
  </pre>

  <h2 id="lvl6">Уровень 6. Безопасность</h2>
  <ul>
    <li>Секрет для HS256 — минимум 32 символа, хранить в переменных окружения (не в гите).</li>
    <li>Access — коротко живёт, Refresh — дольше. Чем меньше окно риска, тем лучше.</li>
    <li>Проверяйте роли на сервере: <code>[Authorize(Roles="Admin")]</code>.</li>
    <li>Осторожно с XSS: мы используем localStorage — внимательны к вводам/скриптам.</li>
  </ul>

  <h2 id="guide">Справочник: аббревиатуры и термины</h2>
  <ul>
    <li><b>iss (Issuer)</b> — кто выдал токен. У нас берётся из конфигурации в <code>API/Program.cs</code> → <code>Jwt:Issuer</code>.</li>
    <li><b>aud (Audience)</b> — для кого токен. У нас <code>Jwt:Audience</code> (клиент Blazor).</li>
    <li><b>sub (Subject)</b> — кто внутри токена: обычно <code>UserId</code>.</li>
    <li><b>exp</b> — срок годности токена (Unix time). Проверяется валидатором <code>ValidateLifetime = true</code> в <code>AddJwtBearer</code>.</li>
    <li><b>iat</b> — когда выдан (Issued At). Добавляется в <code>JwtService</code>.</li>
    <li><b>jti</b> — уникальный ID токена. Полезен для трекинга и отзыва.</li>
    <li><b>role</b> — роль пользователя, проверяется через <code>[Authorize(Roles="...")]</code>.</li>
    <li><b>HS256</b> — алгоритм подписи «секрет + SHA-256». Секрет хранится только на сервере.</li>
    <li><b>Bearer</b> — схема заголовка HTTP: <code>Authorization: Bearer &lt;access_token&gt;</code>.</li>
  </ul>

  <div class="callout info">
    <div class="title">Где в проекте настраивается JWT</div>
    <ul>
      <li><code>API/Program.cs</code> — <b>AddJwtBearer</b> + параметры валидации и Events.OnMessageReceived для SignalR.</li>
      <li><code>API/Services/JwtService.cs</code> — сборка claims и подпись токена.</li>
      <li><code>API/Controllers/AuthController.cs</code> — логин, refresh, revoke.</li>
      <li><code>Blazor/Services/APIService.Auth.cs</code> — вход и сохранение токенов.</li>
      <li><code>Blazor/Services/APIService.TokenRefresh.cs</code> — автообновление при 401.</li>
    </ul>
  </div>

  <h2 id="lifecycle">Жизненный цикл токенов (в нашем проекте)</h2>
  <ol>
    <li><b>Регистрация/логин</b> → <code>AuthController</code> выдаёт <code>access</code> + <code>refresh</code>. Клиент кладёт их в <code>localStorage</code>.</li>
    <li><b>Обычные запросы</b> → клиент отправляет <code>Authorization: Bearer</code>, API пускает на закрытые эндпоинты.</li>
    <li><b>Срок access истёк</b> → запрос получает 401, срабатывает <code>TryWithTokenRefresh</code>.</li>
    <li><b>Обновление</b> → клиент шлёт <code>refresh</code> на <code>/api/Auth/refresh-token</code>, сервер проверяет хеш, ротацию, выдаёт новую пару.</li>
    <li><b>Роли</b> → доступ к эндпоинтам с <code>[Authorize(Roles="...")]</code> по claim <code>role</code>.</li>
    <li><b>Выход</b> → <code>revoke-all-tokens</code> отзывает все активные refresh-токены пользователя, клиент чистит хранилище.</li>
    <li><b>AD-вход</b> → <code>AdAuthController</code> проверяет логин в AD, мапит группы → роли, выдаёт пару токенов.</li>
  </ol>

  <h2 id="lab">Лаборатория: Собери свой токен</h2>
  <p>Локальный конструктор: создаст учебный JWT с подписью HS256 прямо в браузере.</p>
  <div class="builder">
    <div class="grid">
      <label>userId: <input type="number" @bind="BuilderUserId" /></label>
      <label>email: <input type="email" @bind="BuilderEmail" /></label>
      <label>role: <input type="text" @bind="BuilderRole" placeholder="Admin/Manager/Kunde" /></label>
      <label>issuer (iss): <input type="text" @bind="BuilderIssuer" placeholder="H2-2025-API" /></label>
      <label>audience (aud): <input type="text" @bind="BuilderAudience" placeholder="H2-2025-Client" /></label>
      <label>expires (мин): <input type="number" @bind="BuilderExpiryMinutes" /></label>
      <label>secret: <input type="text" @bind="BuilderSecret" placeholder="минимум 32 символа" /></label>
    </div>
    <button class="btn" @onclick="GenerateSampleJwt">Собрать токен</button>
    @if (!string.IsNullOrWhiteSpace(SampleToken))
    {
      <div class="token-out">
        <div>
          <div class="seg h">@SampleHeaderB64</div>
          <div class="seg p">@SamplePayloadB64</div>
          <div class="seg s">@SampleSignatureB64</div>
        </div>
        <div class="mono small">@SampleToken</div>
        <details>
          <summary>Раскрыть payload JSON</summary>
          <pre>@SamplePayloadJson</pre>
        </details>
      </div>
    }
  </div>

  <h2 id="http">HTTP кулинария (примеры запросов)</h2>
  <pre>
POST /api/Auth/register
Content-Type: application/json
{
  "username": "neo",
  "password": "m4trix",
  "email": "neo@matrix.io",
  "firstName": "Neo",
  "lastName": "ChosenOne"
}

POST /api/Auth/login
Content-Type: application/json
{
  "email": "neo@matrix.io",   // или username
  "password": "m4trix"
}
// Ответ: { accessToken, refreshToken, ... }
// Дальше все запросы с заголовком:
Authorization: Bearer &lt;accessToken&gt;

POST /api/Auth/refresh-token
Content-Type: application/json
{ "refreshToken": "&lt;refresh&gt;" }

POST /api/Auth/revoke-all-tokens   // при выходе
(нужен действующий access)
  </pre>

  <h2 id="quiz">Финальный КВИЗ RU/DA</h2>
  <p>Нажимай на варианты. Сразу увидишь «Верно/Неверно». Вопросы даны на русском/датском.</p>
  <div class="quiz">
    @for (int i = 0; i < _questions.Count; i++)
    {
        var questionIndex = i; // локальная копия для замыкания
        var q = _questions[questionIndex];
        <div class="q">
          <div class="qtext"><b>@(questionIndex+1).</b> @q.Text</div>
          <div class="opts">
            @for (int j = 0; j < q.Options.Count; j++)
            {
                var optionIndex = j; // локальная копия для замыкания
                var opt = q.Options[optionIndex];
                var chosen = q.SelectedIndex == optionIndex;
                var cls = q.Answered
                    ? (optionIndex == q.CorrectIndex ? "opt correct" : (chosen ? "opt wrong" : "opt"))
                    : (chosen ? "opt chosen" : "opt");
                <button class="@cls" type="button" @onclick="@(() => SelectAnswer(questionIndex, optionIndex))" disabled="@q.Answered">@opt</button>
            }
          </div>
          @if (q.Answered)
          {
            var isCorrect = q.SelectedIndex == q.CorrectIndex;
            <div class="feedback @(isCorrect ? "correct" : "wrong")">
                @(isCorrect ? "Верно! / Korrekt!" : "Неверно. / Forkert.")
            </div>
            @if (!string.IsNullOrWhiteSpace(q.Explanation))
            {
              <div class="explain"><b>Пояснение:</b> @q.Explanation</div>
            }
          }
        </div>
    }
    <div class="quiz-actions">
      <button class="btn" type="button" @onclick="ShowScore">Показать результат</button>
      <button class="btn ghost" type="button" @onclick="ResetQuiz">Сбросить</button>
    </div>
    @if (_scoreVisible)
    {
      <div class="score">Счёт: <b>@CorrectCount</b> из <b>@_questions.Count</b> — @(ScoreComment)</div>
    }
  </div>

  <h2>Финиш!</h2>
  <p>
    Если дочитал и прошёл квиз — ты приручил токены. Вернись в приложение и попробуй пройти реальный путь:
    логин → запросы → 401 → авто refresh → повтор → logout с revoke-all.
  </p>

  <div class="nav-buttons">
    <a href="/" class="btn">На главную</a>
  </div>
</div>

@code {
  // ===== Навигация по якорям =====
  private async Task ScrollToSection(string sectionId)
  {
      try
      {
          await JS.InvokeVoidAsync("eval", $"document.getElementById('{sectionId}')?.scrollIntoView({{ behavior: 'smooth', block: 'start' }});");
      }
      catch (Exception ex)
      {
          Console.WriteLine($"[SCROLL] Error scrolling to {sectionId}: {ex.Message}");
      }
  }

  // ===== Локальный конструктор JWT =====
  int BuilderUserId { get; set; } = 1;
  string BuilderEmail { get; set; } = "student@example.com";
  string BuilderRole { get; set; } = "Kunde";
  string BuilderIssuer { get; set; } = "H2-2025-API";
  string BuilderAudience { get; set; } = "H2-2025-Client";
  int BuilderExpiryMinutes { get; set; } = 60;
  string BuilderSecret { get; set; } = "this_is_a_demo_secret_with_32+_chars_length";

  string? SampleToken { get; set; }
  string SampleHeaderB64 { get; set; } = string.Empty;
  string SamplePayloadB64 { get; set; } = string.Empty;
  string SampleSignatureB64 { get; set; } = string.Empty;
  string SamplePayloadJson { get; set; } = string.Empty;

  void GenerateSampleJwt()
  {
      var now = DateTimeOffset.UtcNow;
      var iat = now.ToUnixTimeSeconds();
      var exp = now.AddMinutes(Math.Max(1, BuilderExpiryMinutes)).ToUnixTimeSeconds();

      var headerObj = new Dictionary<string, object> { ["alg"] = "HS256", ["typ"] = "JWT" };
      var payloadObj = new Dictionary<string, object>
      {
          ["sub"] = BuilderUserId.ToString(),
          ["email"] = BuilderEmail,
          ["role"] = BuilderRole,
          ["iss"] = BuilderIssuer,
          ["aud"] = BuilderAudience,
          ["iat"] = iat,
          ["exp"] = exp,
          ["jti"] = Guid.NewGuid().ToString()
      };

      var headerJson = JsonSerializer.Serialize(headerObj);
      var payloadJson = JsonSerializer.Serialize(payloadObj);

      var headerB64 = Base64UrlEncode(Encoding.UTF8.GetBytes(headerJson));
      var payloadB64 = Base64UrlEncode(Encoding.UTF8.GetBytes(payloadJson));
      var signature = ComputeHmacSha256($"{headerB64}.{payloadB64}", BuilderSecret);
      var signatureB64 = Base64UrlEncode(signature);

      SampleHeaderB64 = headerB64;
      SamplePayloadB64 = payloadB64;
      SampleSignatureB64 = signatureB64;
      SamplePayloadJson = payloadJson;
      SampleToken = $"{headerB64}.{payloadB64}.{signatureB64}";
  }

  static byte[] ComputeHmacSha256(string data, string secret)
  {
      using var h = new HMACSHA256(Encoding.UTF8.GetBytes(secret));
      return h.ComputeHash(Encoding.UTF8.GetBytes(data));
  }

  static string Base64UrlEncode(byte[] bytes)
  {
      return Convert.ToBase64String(bytes).TrimEnd('=') .Replace('+', '-') .Replace('/', '_');
  }

  // ===== Квиз =====
  class QuizQuestion
  {
      public string Text { get; set; } = string.Empty;
      public List<string> Options { get; set; } = new();
      public int CorrectIndex { get; set; }
      public string? Explanation { get; set; }
      public int? SelectedIndex { get; set; }
      public bool Answered { get; set; }
  }

  private List<QuizQuestion> _questions = new();
  private bool _scoreVisible;
  
  // Общий ГСЧ для перемешиваний
  private static readonly Random _rng = new Random();
  
  int CorrectCount => _questions.Count(q => q.Answered && q.SelectedIndex == q.CorrectIndex);
  string ScoreComment => CorrectCount switch
  {
      >= 32 => "Легенда токенов / Token-legende 🏆",
      >= 27 => "Гранд-мастер / Stormester ✨",
      >= 22 => "Уверенный / Sikker 👍",
      >= 16 => "База есть / Grundlag på plads 🙂",
      _ => "Нужно повторить / Skal gentages 🔁"
  };

  void SelectAnswer(int qi, int oi)
  {
      if (qi < 0 || qi >= _questions.Count) return;
      var q = _questions[qi];
      if (oi < 0 || oi >= q.Options.Count) return;

      q.SelectedIndex = oi;
      q.Answered = true;
      StateHasChanged();
      Console.WriteLine($"[QUIZ] Answer selected: Q={qi}, Opt={oi}, Correct={(oi == q.CorrectIndex)}");
  }

  void ShowScore()
  {
      _scoreVisible = true;
      StateHasChanged();
      Console.WriteLine($"[QUIZ] ShowScore clicked. Correct={CorrectCount}/{_questions.Count}");
  }

  void ResetQuiz()
  {
      // Пересобираем вопросы, чтобы заново перемешать варианты
      _questions = BuildQuestions();
      _scoreVisible = false;
      StateHasChanged();
      Console.WriteLine("[QUIZ] ResetQuiz clicked — questions randomized.");
  }

  protected override void OnInitialized()
  {
      if (_questions.Count == 0)
      {
          _questions = BuildQuestions();
          Console.WriteLine($"[QUIZ] Initialized. Questions={_questions.Count}");
      }
  }

  List<QuizQuestion> BuildQuestions()
  {
      return new List<QuizQuestion>
      {
          // ===== УРОВЕНЬ: БАЗА (1-5) =====
          Q("Что такое JWT? / Hvad er JWT?",
            new[]{"Подписанный JSON-объект / Signeret JSON-objekt","База данных в браузере / Browser-database","Сжатый файл / Komprimeret fil"}, 0,
            "JWT (JSON Web Token) — это стандарт (RFC 7519) для создания токенов, удостоверяющих личность."),

          Q("Какие три части у JWT? / Hvad består et JWT af?",
            new[]{"Header, Payload, Signature","User, Pass, Secret","Issuer, Audience, Subject"}, 0,
            "Токен состоит из трёх частей через точки: заголовок, полезная нагрузка и подпись."),

          Q("Подпись токена означает, что он зашифрован? / Betyder signaturen, at den er krypteret?",
            new[]{"Нет, его содержимое может прочитать любой / Nej, indholdet kan læses af alle","Да, его никто не может прочитать / Ja, ingen kan læse det"}, 0,
            "Подпись защищает от подделки. Payload читается после Base64Url-декодирования."),

          Q("Какой HTTP-заголовок используется для токена? / Hvilken HTTP-header bruges til tokenet?",
            new[]{"Authorization: Bearer <token>","Auth: JWT <token>","X-Access-Token: <token>"}, 0,
            "Стандартная схема Bearer в заголовке Authorization."),

          Q("Зачем нужен refresh-токен? / Hvorfor har vi brug for et refresh-token?",
            new[]{"Чтобы безопасно обновить access-токен / For sikkert at forny et access-token","Для входа в систему / Til at logge ind","Для записи логов / Til at skrive logs"}, 0,
            "Access живёт недолго. Когда истекает, refresh используется для нового access без логина."),

          // ===== УРОВЕНЬ: СРЕДНИЙ (6-15) =====
          Q("Почему access-токен делают короткоживущим? / Hvorfor har access-tokens en kort levetid?",
            new[]{"Чтобы уменьшить риск при краже / For at mindske risikoen","Чтобы чаще запрашивать refresh / For at anmode om refresh oftere","Чтобы снизить нагрузку на сервер / For at reducere serverbelastningen"}, 0,
            "Если access украдут, злоумышленник сможет использовать его лишь короткое время."),

          Q("Что такое 'Issuer' (iss) и 'Audience' (aud)? / Hvad er 'Issuer' (iss) og 'Audience' (aud)?",
            new[]{"Кто выдал токен и для кого / Hvem udstedte tokenet, og hvem er det til","Имя и фамилия пользователя / Brugers navn","URL сервера и клиента / Server- og klient-URL"}, 0,
            "Issuer — сервер-издатель, Audience — клиент. Задаются в API/Program.cs."),

          Q("Что обычно включают в claims? / Hvad inkluderer man typisk i claims?",
            new[]{"ID пользователя, роль, срок действия / Bruger-ID, rolle, udløb","IP-адрес и User-Agent","Секретный ключ сервера"}, 0,
            "В API/Services/JwtService.cs добавляем NameIdentifier, Email, Role, jti, iat."),

          Q("Где в коде включается JWT-аутентификация? / Hvor i koden aktiveres JWT-autentificering?",
            new[]{"В API/Program.cs через AddJwtBearer","В Blazor/Program.cs","В README.md"}, 0,
            "API/Program.cs: builder.Services.AddAuthentication(...).AddJwtBearer(...)."),

          Q("Как refresh-токен хранится на сервере? / Hvordan gemmes refresh-tokenet på serveren?",
            new[]{"В виде хеша / Som et hash","В открытом виде / I klartekst","Он не хранится / Det gemmes ikke"}, 0,
            "API/Models/RefreshToken хранит TokenHash (SHA-256)."),

          Q("Что такое 'ротация' refresh-токенов? / Hvad er rotation af refresh-tokens?",
            new[]{"Старый отзывается, выдаётся новый / Det gamle tilbagekaldes, et nyt udstedes","Меняется роль пользователя","Меняется алгоритм подписи"}, 0,
            "В AuthController.RefreshToken старый помечается revoked, выдаётся новая пара."),

          Q("Где должен храниться секретный ключ для подписи? / Hvor skal signeringshemmeligheden gemmes?",
            new[]{"В переменных окружения или Key Vault","В appsettings.json в репозитории","В базе данных"}, 0,
            "Не храните секреты в коде — используйте env/Key Vault."),

          Q("Как клиент понимает, что access истёк? / Hvordan ved klienten, at access er udløbet?",
            new[]{"Получает 401 и запускает авто-обновление / Modtager 401 og fornyer","Сервер шлёт e-mail","Браузер падает"}, 0,
            "Blazor/Services/APIService.TokenRefresh.cs → TryWithTokenRefresh перехватывает 401."),

          Q("Где клиент хранит токены в нашем проекте? / Hvor gemmer klienten tokens i vores projekt?",
            new[]{"localStorage","Cookies (HttpOnly)","sessionStorage"}, 0,
            "Blazor/Services/APIService.Auth.cs сохраняет access_token и refresh_token в localStorage."),

          Q("Что такое 'jti' (JWT ID)? / Hvad er 'jti' (JWT ID)?",
            new[]{"Уникальный идентификатор токена / Unikt token-ID","Почтовый индекс / Postnummer","Тип контента / Indholdstype"}, 0,
            "Claim для уникального ID каждого токена (трекинг/отзыв)."),

          // ===== УРОВЕНЬ: СЛОЖНЫЙ (16-25) =====
          Q("Что означает claim 'iat' (Issued At)? / Hvad betyder 'iat' (Issued At) claim?",
            new[]{"Время, когда токен выдан / Tidspunktet for udstedelse","Роль пользователя","Алгоритм подписи"}, 0,
            "Unix time метка создания токена."),

          Q("Чем логин через Active Directory отличается? / Hvordan adskiller AD-login sig?",
            new[]{"Сервер проверяет учётные данные в AD","Пароль хранится в JWT","Токен приходит по e-mail"}, 0,
            "API/Controllers/AdAuthController.cs использует AdLdapAuthService."),

          Q("Что делает эндпоинт revoke-all-tokens? / Hvad gør revoke-all-tokens endpointet?",
            new[]{"Отзывает все refresh-токены пользователя","Меняет пароль пользователя","Удаляет аккаунт"}, 0,
            "Полный logout со всех устройств (AuthController.RevokeAllTokens)."),

          Q("Можно ли доверять payload без проверки подписи? / Kan man stole på payload uden signaturtjek?",
            new[]{"Нет, только после верификации подписи","Да, всегда","Только если HTTPS"}, 0,
            "Единственная гарантия подлинности — успешная проверка подписи на сервере."),

          Q("Сколько активных refresh-токенов допускается на пользователя? / Hvor mange aktive refresh-tokens pr. bruger?",
            new[]{"До 5 / Op til 5","Только 1","Неограниченно"}, 0,
            "В AuthController.Login при 6-м входе самый старый активный токен отзывается."),

          Q("Что произойдёт при повторном использовании отозванного refresh-токена? / Hvad sker der ved genbrug af et tilbagekaldt refresh-token?",
            new[]{"Все активные токены пользователя будут отозваны","Ничего","Пользователь получит предупреждение"}, 0,
            "Признак атаки reuse — отзывает все активные токены (token_reuse_detected)."),

          Q("Как в C# потребовать роль на эндпоинте? / Hvordan kræves en rolle på et endpoint i C#?",
            new[]{"Атрибутом [Authorize(Roles=\"Admin\")]","[HttpGet]","[FromBody]"}, 0,
            "[Authorize] с Roles фильтрует доступ по ClaimTypes.Role."),

          Q("Какой маршрут у AD-логина в нашем API? / Hvad er ruten for AD-login i vores API?",
            new[]{"POST api/adauth/login","POST api/ad/login","POST api/Auth/ad-login"}, 0,
            "См. API/Controllers/AdAuthController.cs: [Route(\"api/adauth\")] + [HttpPost(\"login\")]."),

          Q("Что делает клиент после успешного RefreshAccessToken? / Hvad gør klienten efter en vellykket RefreshAccessToken?",
            new[]{"Обновляет Authorization заголовок новым access-токеном","Ничего не меняет","Перезапускает приложение"}, 0,
            "Blazor/Services/APIService.TokenRefresh.cs обновляет DefaultRequestHeaders.Authorization."),

          Q("Как защитить SignalR-хаб с помощью JWT? / Hvordan beskytter man en SignalR-hub med JWT?",
            new[]{"Передать токен в query string при подключении","Открыть хаб для всех","Использовать отдельный пароль"}, 0,
            "WebSocket не позволяет кастомные заголовки — токен в URL; сервер читает его в OnMessageReceived."),

          // ===== УРОВЕНЬ: СВЕРХСЛОЖНЫЙ (26-35) =====
          Q("Когда JwtBearer берёт токен из query string access_token? / Hvornår tager JwtBearer tokenet fra query string access_token?",
            new[]{"Только для запросов к /hubs/tickets","Для всех запросов","Только в Debug"}, 0,
            "API/Program.cs: Events.OnMessageReceived — только если путь начинается с /hubs/tickets."),

          Q("Что означает ClockSkew = TimeSpan.Zero в AddJwtBearer? / Hvad betyder ClockSkew = TimeSpan.Zero i AddJwtBearer?",
            new[]{"Токен истекает строго по exp без окна допуска","Добавляется 5 минут допуска","exp не проверяется"}, 0,
            "Строгая экспирация без доп. окна."),

          Q("Какое минимальное требование к длине секрета в JwtService? / Hvad er minimumskravet til hemmelighedens længde i JwtService?",
            new[]{"Не менее 32 символов; иначе будет exception","Не менее 16; будет предупреждение","Любая длина; секрет дополнится нулями"}, 0,
            "API/Services/JwtService.cs выбрасывает ArgumentException, если длина < 32."),

          Q("Для чего используется JwtService.GetPrincipalFromExpiredToken? / Hvad bruges JwtService.GetPrincipalFromExpiredToken til?",
            new[]{"Получить ClaimsPrincipal даже из просроченного токена","Удалить токен из БД","Продлить срок действия токена"}, 0,
            "Валидация с ValidateLifetime = false для извлечения claims."),

          Q("Что сохраняется в ReplacedByToken при ротации refresh-токена? / Hvad gemmes i ReplacedByToken ved rotation?",
            new[]{"Хеш нового refresh-токена","Текст нового токена","jti из access-токена"}, 0,
            "AuthController.RefreshToken присваивает hash нового токена (TokenHash)."),

          Q("Какие env-переменные используются как fallback для JWT настроек? / Hvilke miljøvariabler bruges som fallback for JWT-indstillinger?",
            new[]{"JWT__SecretKey, JWT__Issuer, JWT__Audience","JWT_SECRET, JWT_ISS, JWT_AUD","ASPNETCORE_JWT_SECRET, ISS, AUD"}, 0,
            "API/Program.cs и JwtService.cs читают из окружения ключи JWT__SecretKey/JWT__Issuer/JWT__Audience."),

          Q("Какой алгоритм хеширования используется для RefreshToken.TokenHash? / Hvilken hash-algoritme bruges til RefreshToken.TokenHash?",
            new[]{"SHA-256","MD5","SHA-1"}, 0,
            "API/Models/RefreshToken.cs: ComputeTokenHash использует SHA256 и возвращает Base64-строку."),

          Q("Почему обычный логин запрещён для AD-учёток? / Hvorfor er almindelig login blokeret for AD-konti?",
            new[]{"Потому что HashedPassword пустой или равен \"AD\"","Потому что отсутствует email","Потому что роль Admin"}, 0,
            "AuthController.Login: если HashedPassword пуст или равен \"AD\", возвращается BadRequest с предложением использовать /api/adauth/login."),

          Q("Какое значение RevokedReason ставится при превышении лимита 5 refresh-токенов? / Hvilken RevokedReason sættes ved overskridelse af 5 refresh-tokens?",
            new[]{"exceeded_limit","too_many","limit_reached"}, 0,
            "AuthController.Login помечает самый старый активный токен: RevokedReason = \"exceeded_limit\"."),

          Q("Какое значение RevokedReason ставится при ротации refresh-токена? / Hvilken RevokedReason sættes ved rotation af refresh-token?",
            new[]{"rotated","replaced","rotation"}, 0,
            "AuthController.RefreshToken: для старого токена RevokedReason = \"rotated\"."),
      };
  }

  static QuizQuestion Q(string text, string[] options, int correct, string? explanation = null)
  {
      // Перемешиваем варианты и вычисляем новый индекс правильного
      var opts = options.ToList();
      if (opts.Count == 0) throw new ArgumentException("Options must not be empty");
      if (correct < 0 || correct >= opts.Count) throw new ArgumentOutOfRangeException(nameof(correct));

      var correctValue = opts[correct];

      // Fisher–Yates shuffle
      for (int i = opts.Count - 1; i > 0; i--)
      {
          int j = _rng.Next(i + 1);
          (opts[i], opts[j]) = (opts[j], opts[i]);
      }

      // Находим новый индекс правильного варианта
      var newCorrectIndex = opts.FindIndex(o => string.Equals(o, correctValue, StringComparison.Ordinal));
      if (newCorrectIndex < 0) newCorrectIndex = 0; // подстраховка на случай дубликатов

      return new QuizQuestion
      {
          Text = text,
          Options = opts,
          CorrectIndex = newCorrectIndex,
          Explanation = explanation
      };
  }
}
