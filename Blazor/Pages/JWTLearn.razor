@page "/jwt-learn"
@using System.Text
@using System.Text.Json
@using System.Security.Cryptography
@inject IJSRuntime JS

<PageTitle>JWT Learn — Приручи токены</PageTitle>

<link href="css/jwt-learn.css" rel="stylesheet" />

<div class="jwt-page">
  <h1>JWT Learn — Игра «Приручи токены»</h1>
  <p>
    Добро пожаловать в <strong>лучший курс по JWT</strong>! Забудь всё, что ты читал до этого. Здесь мы объясняем так, будто ты сидишь с другом на кухне, но с технической точностью, как в документации. Наша цель — сделать из тебя специалиста по токенам, даже если ты начинаешь с нуля.
    К концу урока ты сможешь сам собрать JWT, авторизоваться в API, понять, как работает обновление токенов, и победишь в финальном квизе.
  </p>

  <div class="toc">
    <b>Карта уровней:</b>
    <a @onclick="@(() => ScrollToSection("lvl1"))" style="cursor: pointer;">Уровень 1. Что такое JWT (для чайников)</a>
    <a @onclick="@(() => ScrollToSection("lvl2"))" style="cursor: pointer;">Уровень 2. Сервер: строим проходную</a>
    <a @onclick="@(() => ScrollToSection("lvl3"))" style="cursor: pointer;">Уровень 3. Клиент: получаем пропуск</a>
    <a @onclick="@(() => ScrollToSection("lvl4"))" style="cursor: pointer;">Уровень 4. Active Directory: вход для корпоративных</a>
    <a @onclick="@(() => ScrollToSection("lvl5"))" style="cursor: pointer;">Уровень 5. Refresh & Rotation: магия обновления</a>
    <a @onclick="@(() => ScrollToSection("lvl6"))" style="cursor: pointer;">Уровень 6. Безопасность: как не облажаться</a>
    <a @onclick="@(() => ScrollToSection("why"))" style="cursor: pointer;">Почему так, а не иначе?</a>
    <a @onclick="@(() => ScrollToSection("lab"))" style="cursor: pointer;">Лаборатория: Собери свой токен</a>
    <a @onclick="@(() => ScrollToSection("http"))" style="cursor: pointer;">HTTP кулинария</a>
    <a @onclick="@(() => ScrollToSection("guide"))" style="cursor: pointer;">Справочник терминов</a>
    <a @onclick="@(() => ScrollToSection("lifecycle"))" style="cursor: pointer;">Жизненный цикл токена</a>
    <a @onclick="@(() => ScrollToSection("quiz"))" style="cursor: pointer;">Финальный КВИЗ RU/DA</a>
  </div>

  <h2 id="lvl1">Уровень 1. Что такое JWT (для чайников)</h2>
  <p>
    Представь, что наше приложение — это большой завод. Чтобы попасть внутрь и ходить по цехам, тебе нужен пропуск. JWT (JSON Web Token) — это и есть твой <strong>цифровой пропуск</strong>.
  </p>
  <ul>
    <li>Когда ты вводишь логин и пароль, ты как бы подходишь к охраннику на проходной. Он проверяет твои документы и выдаёт тебе пропуск (токен).</li>
    <li>На пропуске написано: кто ты (ID 123, "Вася Пупкин"), в какие цеха тебе можно ("цех А", "столовая"), и до скольки пропуск действует (до конца смены).</li>
    <li>Самое главное: на пропуске есть <strong>печать и подпись начальника охраны</strong>. Эту подпись нельзя подделать. Если ты попробуешь сам дорисовать себе доступ в "цех Б", охранник на входе в цех сразу это заметит и не пустит.</li>
  </ul>
  <p>Вот так и устроен JWT. Он состоит из трёх частей, соединённых точками:</p>
  <div class="token-parts">
    <div class="part header">HEADER (Заголовок)</div>
    <div class="dot">.</div>
    <div class="part payload">PAYLOAD (Данные)</div>
    <div class="dot">.</div>
    <div class="part signature">SIGNATURE (Подпись)</div>
  </div>
  <ul>
    <li>
      <b>Header (Заголовок)</b>: Техническая информация. Говорит: "Это JWT, и для подписи мы использовали секретный шифр HS256".
      <pre>{"alg": "HS256", "typ": "JWT"}</pre>
    </li>
    <li>
      <b>Payload (Полезная нагрузка)</b>: Та самая информация на пропуске. Кто ты, какие у тебя права (роли), когда выдан, когда сгорит.
      <pre>{"sub": "123", "role": "Admin", "exp": 1678886400}</pre>
    </li>
    <li>
      <b>Signature (Подпись)</b>: Самая важная часть. Сервер берёт заголовок, данные, добавляет к ним <strong>секретный ключ</strong> (который знает только он) и создаёт уникальную подпись. Если кто-то изменит хоть одну букву в данных, подпись перестанет совпадать.
    </li>
  </ul>
  <div class="callout info">
    <div class="title">Важный момент!</div>
    JWT не зашифрован. Любой может прочитать, что написано в Payload. Его задача — не скрыть информацию, а <strong>гарантировать, что она не подделана</strong>. Не храни в нём пароли или секреты!
  </div>

  <h2 id="lvl2">Уровень 2. Сервер: строим проходную</h2>
  <p>
    Чтобы наш "завод" (API) понимал, что такое JWT-пропуска и как их проверять, мы должны его научить. Это происходит в файле <code>API/Program.cs</code>.
  </p>
  
  <h3>Шаг 1. Учим API понимать JWT</h3>
  <p>Мы добавляем "инструкцию" для охранников, как проверять пропуска. Это делается кодом ниже.</p>
  <pre>
// API/Program.cs
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            // 1. Проверять, кто выдал пропуск (Issuer)
            ValidateIssuer = true,
            // 2. Проверять, для кого выдан пропуск (Audience)
            ValidateAudience = true,
            // 3. Проверять, не истёк ли срок действия
            ValidateLifetime = true,
            // 4. Проверять подлинность подписи
            ValidateIssuerSigningKey = true,
            // 5. Не давать дополнительного времени (если пропуск до 17:00, то в 17:00:01 он уже не работает)
            ClockSkew = TimeSpan.Zero,
            // "Правильный" издатель пропуска
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            // "Правильный" получатель (наше Blazor-приложение)
            ValidAudience = builder.Configuration["Jwt:Audience"],
            // Тот самый секретный ключ для проверки подписи
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:SecretKey"]))
        };
    });
  </pre>
  <b>Простыми словами:</b>
  <ul>
    <li><code>AddAuthentication</code>: "Эй, сервер, мы будем проверять пользователей".</li>
    <li><code>AddJwtBearer</code>: "Проверять будем по JWT-пропускам (токенам)".</li>
    <li><code>TokenValidationParameters</code>: "А вот правила проверки: пропуск должен быть выдан НАШИМ заводом, предназначен для НАШЕГО сотрудника, быть свежим и иметь НАШУ подлинную подпись".</li>
  </ul>

  <h3>Шаг 2. Создаём пропуска (токены)</h3>
  <p>
    Этим занимается специальный "станок" — <code>JwtService.cs</code>. Когда пользователь ввёл правильный логин/пароль, мы вызываем этот сервис, чтобы он сделал новенький пропуск.
  </p>
  <pre>
// API/Services/JwtService.cs — метод GenerateToken
var claims = new[]
{
    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()), // ID пользователя
    new Claim(ClaimTypes.Email, user.Email),                   // Его email
    new Claim(ClaimTypes.Role, roleName),                      // Его роль (доступ в цеха)
    new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) // Уникальный номер пропуска
};

var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_secretKey));
var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

var token = new JwtSecurityToken(
    issuer: _issuer,
    audience: _audience,
    claims: claims,
    expires: DateTime.UtcNow.AddMinutes(15), // Пропуск действует 15 минут
    signingCredentials: creds
);

return new JwtSecurityTokenHandler().WriteToken(token);
  </pre>
  <div>
    <b>Простыми словами:</b>
    <ol>
      <li>Собираем "claims" — всю информацию, которую хотим записать на пропуск (ID, роль и т.д.).</li>
      <li>Берём наш секретный ключ (<code>_secretKey</code>) и выбираем алгоритм подписи (<code>HmacSha256</code>).</li>
      <li>Создаём сам токен: указываем, кто выдал, для кого, какие данные внутри, до скольки он действует.</li>
      <li>Подписываем его (<code>signingCredentials</code>).</li>
      <li>Превращаем готовый объект токена в строку (<code>WriteToken</code>) и отдаём пользователю.</li>
    </ol>
  </div>

  <h3>Шаг 3. Ставим охрану на входе в "цеха"</h3>
  <p>
    Чтобы в важный цех не попал кто попало, мы вешаем на "дверь" (эндпоинт) табличку "Вход только по пропускам".
  </p>
  <pre>
// Контроллер в API, например, TicketsController.cs

// На эту "дверь" может войти любой с действующим пропуском
[Authorize]
[HttpGet("api/tickets/mine")]
public IActionResult GetMyTickets() { ... }

// А сюда — только тот, у кого на пропуске написано "Admin"
[Authorize(Roles = "Admin")]
[HttpGet("api/tickets/all")]
public IActionResult GetAllTickets() { ... }
  </pre>
  <p>Атрибут <code>[Authorize]</code> — это и есть тот самый охранник, который проверяет пропуск перед входом.</p>

  <h2 id="lvl3">Уровень 3. Клиент: получаем пропуск</h2>
  <p>
    Наш Blazor-фронтенд — это "сотрудник", который ходит по "заводу". Ему нужно где-то хранить свой пропуск и показывать его на каждом входе.
  </p>
  
  <h3>Шаг 1. Логинимся и сохраняем пропуск</h3>
  <p>Когда пользователь вводит логин/пароль, мы отправляем их на сервер. Если всё верно, сервер возвращает два токена: <code>access_token</code> и <code>refresh_token</code>. Мы их сохраняем.</p>
  <pre>
// Blazor/Services/APIService.Auth.cs
var response = await _httpClient.PostAsJsonAsync("api/Auth/login", user);
var result = await response.Content.ReadFromJsonAsync&lt;AuthResponseDto&gt;();

// Кладём access_token в "карман" браузера — localStorage
await _js.InvokeVoidAsync("localStorage.setItem", "access_token", result.AccessToken);
// Refresh_token тоже прячем в localStorage
await SaveRefreshToken(result.RefreshToken);
  </pre>
  <p>
    <b>Почему <code>localStorage</code>?</b> Это как карман в куртке. Он доступен, пока ты не закроешь браузер и не откроешь его заново. Это простое хранилище "ключ-значение" прямо в браузере. Подробнее об этом — в разделе "Почему так, а не иначе?".
  </p>

  <h3>Шаг 2. Показываем пропуск при каждом запросе</h3>
  <p>
    Чтобы каждый раз не логиниться, мы при каждом походе в "цех" (запросе к API) автоматически показываем наш пропуск.
  </p>
  <pre>
// Blazor/Program.cs
builder.Services.AddHttpClient("API", (sp, client) =>
{
    // ...
    // При создании "транспорта" для запросов...
    var token = await localStorage.GetItemAsync&lt;string&gt;("access_token");
    if (token != null)
    {
        // ...мы сразу добавляем заголовок с пропуском
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
    }
});
  </pre>
  <p>
    Это значит, что любой запрос к API будет уходить с заголовком <code>Authorization: Bearer &lt;наш_длинный_токен&gt;</code>. Сервер видит этот заголовок и проверяет пропуск.
  </p>

  <h3>Шаг 3. Что делать, если пропуск просрочен?</h3>
  <p>
    Наш <code>access_token</code> живёт недолго (15 минут). Когда он "протухает", сервер отвечает ошибкой <code>401 Unauthorized</code> (Не авторизован). Это как если бы охранник сказал: "Ваш пропуск истёк, идите на проходную за новым".
  </p>
  <p>
    Но заставлять пользователя снова вводить пароль — плохая идея. Для этого у нас есть <code>refresh_token</code>! Наш код автоматически перехватывает ошибку 401 и пытается обновить пропуск.
  </p>
  <pre>
// Blazor/Services/APIService.TokenRefresh.cs
// Это обёртка для любого запроса
async Task&lt;HttpResponseMessage&gt; TryWithTokenRefresh(Func&lt;Task&lt;HttpResponseMessage&gt;&gt; request)
{
    // 1. Сначала просто делаем запрос
    var response = await request();

    // 2. Если сервер ответил "401 - пропуск недействителен"
    if (response.StatusCode == HttpStatusCode.Unauthorized)
    {
        // 3. Пытаемся обновить его с помощью refresh_token
        var refreshed = await RefreshAccessToken();
        if (refreshed)
        {
            // 4. Если получилось, повторяем исходный запрос. Он теперь пройдёт!
            return await request();
        }
    }
    return response;
}
  </pre>
  <p>Эта магия происходит незаметно для пользователя. Для него всё просто работает. Подробнее об этом — в ра��деле про Refresh & Rotation.</p>

  <h2 id="lvl4">Уровень 4. Active Directory вход</h2>
  <ul>
    <li>Это специальный вход для "корпоративных" сотрудников, у которых уже есть учётная запись в Windows (Active Directory).</li>
    <li>Им не нужно регистрироваться в нашей системе. Они просто вводят свой рабочий логин и пароль.</li>
    <li>Наш сервер идёт в Active Directory, спрашивает: "Есть такой сотрудник? Пароль верный?".</li>
    <li>Если да, сервер смотрит, в каких группах состоит сотрудник (например, "Бухгалтерия", "Разработчики"), и превращает их в наши роли ("Manager", "Admin").</li>
    <li>Дальше всё как обычно: сервер создаёт JWT-пропуск (токен) с нужной ролью и отдаёт его клиенту. Для клиента нет никакой разницы, как был получен токен.</li>
    <li>Эндпоинт для этого: <code>POST api/adauth/login</code>.</li>
  </ul>

  <h2 id="lvl5">Уровень 5. Refresh & Rotation: магия обновления</h2>
  <p>Это одна из самых важных и хитрых тем. Давай разберёмся.</p>
  <p>У нас есть два ключа:</p>
  <ul>
    <li><b>Access Token (Пропуск)</b>: Короткоживущий (15 минут). Мы показываем его на каждом шагу. Если его украдут, злоумышленник сможет пользоваться им только 15 минут.</li>
    <li><b>Refresh Token (Мастер-ключ)</b>: Долгоживущий (например, 7 дней). Он нужен только для одного — получить новый "Пропуск", когда старый истёк. Он хранится в надёжном месте и используется очень редко.</li>
  </ul>

  <h3>Как работает обновление?</h3>
  <ol>
    <li>"Пропуск" (access token) истёк. Сервер вернул ошибку 401.</li>
    <li>Наш клиент (Blazor) достаёт из кармана "Мастер-ключ" (refresh token).</li>
    <li>Идёт на специальный эндпоинт <code>/api/Auth/refresh-token</code> и говорит: "Вот мой Мастер-ключ, дай мне новый Пропуск".</li>
    <li>Сервер проверяет Мастер-ключ по своей базе. Если он настоящий и не отозван, сервер делает две вещи:
      <ul>
        <li>Создаёт <strong>новую пару</strong>: свежий "Пропуск" на 15 минут и совершенно новый "Мастер-ключ" на 7 дней.</li>
        <li>Старый "Мастер-ключ" помечает в базе как "использованный".</li>
      </ul>
    </li>
    <li>Клиент получает новую пару, сохраняет её и повторяет свой изначальный запрос, который теперь проходит успешно.</li>
  </ol>
  <p>Этот процесс называется <strong>Ротация токенов (Token Rotation)</strong>. Каждый раз, когда ты используешь refresh-токен, тебе выдают новый, а старый сжигают. Это очень важно для безопасности!</p>

  <h3>Защита от кражи Refresh-токена</h3>
  <p>
    Представь, что хакер украл твой refresh-токен из браузера. Что произойдёт?
  </p>
  <ul>
    <li>Ты продолжаешь работать. Твой access-токен истекает, и твой браузер идёт за новым, используя refresh-токен. Ты получаешь новую пару (access_2, refresh_2), а старый (refresh_1) помечается на сервере как "использованный".</li>
    <li>Теперь хакер пытается использовать украденный refresh_1. Он приходит на сервер, а сервер видит: "Стоп! Этот токен уже был использован для выпуска refresh_2. Кто-то пытается использовать его повторно! Тревога!".</li>
    <li>В этот момент сервер <strong>немедленно отзывает ВСЕ refresh-токены</strong> этого пользователя. Твой refresh_2 тоже становится недействительным.</li>
    <li>При следующей попытке обновить токен твой браузер получит отказ. Тебя "выкинет" из системы, и придётся заново вводить логин и пароль. Хакер тоже ничего не сможет сделать.</li>
  </ul>
  <p>Это умный механизм, который позволяет обнаружить кражу и обезопасить аккаунт.</p>

  <h2 id="lvl6">Уровень 6. Безопасность: как не облажаться</h2>
  <ul>
    <li><strong>Секретный ключ — это всё.</strong> Храни его как зеницу ока. Он не должен быть в коде или в Git. Используй переменные окружения (как в нашем проекте) или специальные сервисы (Azure Key Vault). Ключ должен быть длинным и сложным (минимум 32 символа).</li>
    <li><strong>Короткая жизнь access-токена.</strong> 5-15 минут — идеально. Чем меньше, тем лучше.</li>
    <li><strong>HTTPS — обязательно.</strong> Всегда используй шифрование (SSL/TLS), чтобы твои токены не перехватили по пути от клиента к серверу.</li>
    <li><strong>Не доверяй клиенту.</strong> Всегда проверяй роли и права на сервере с помощью <code>[Authorize(Roles="...")]</code>. Нельзя полагаться на то, что фронтенд просто не покажет кнопку "Удалить".</li>
    <li><strong>XSS-атаки.</strong> Если на твоём сайте есть уязвимость, позволяющая выполнить чужой JavaScript-код (XSS), то хакер сможет украсть токены из <code>localStorage</code>. Поэтому важно "чистить" любой пользовательский ввод.</li>
  </ul>

  <h2 id="why">Почему так, а не иначе?</h2>
  <div class="callout info">
    <div class="title">JWT vs. Сессии (Sessions)</div>
    <p>
      Раньше были популярны <strong>сессии</strong>. Это когда сервер после логина создавал у себя временную "карточку" пользователя и давал браузеру только её номер (в cookie). При каждом запросе браузер показывал номер, а сервер искал карточку у себя в памяти или базе.
    </p>
    <ul>
      <li><strong>Проблема сессий:</strong> Это создаёт "состояние" на сервере (stateless vs stateful). Если у тебя много серверов (масштабирование), то им всем нужна общая база сессий, что сложно.</li>
      <li><strong>Преимущество JWT:</strong> Серверу ничего не нужно хранить. Вся информация — в самом токене. Любой из твоих 100 серверов сможет проверить токен, зная секретный ключ. Это называется <strong>stateless</strong> (не хранящий состояние) и отлично подходит для современных архитектур (микросервисы).</li>
    </ul>
  </div>
  <div class="callout info">
    <div class="title">localStorage vs. Cookies</div>
    <p>
      Где хранить токены на клиенте — вечный спор.
    </p>
    <ul>
      <li>
        <strong>Cookies (HttpOnly, Secure, SameSite=Strict):</strong>
        <ul>
          <li><strong>Плюс:</strong> Более безопасны от XSS-атак, так как их нельзя прочитать через JavaScript. Браузер сам автоматически отправляет их с каждым запросом.</li>
          <li><strong>Минус:</strong> Уязвимы для CSRF-атак (Cross-Site Request Forgery), хотя атрибут <code>SameSite</code> это почти решает. Сложнее в настройке, особенно при работе с разными доменами (CORS).</li>
        </ul>
      </li>
      <li>
        <strong>localStorage:</strong>
        <ul>
          <li><strong>Плюс:</strong> Очень просто использовать. JavaScript может легко читать и записывать токены. Удобно для SPA-приложений (как наше). Нет проблем с CSRF.</li>
          <li><strong>Минус:</strong> Уязвимы для XSS. Если хакер сможет запустить свой скрипт на вашей странице, он украдёт токены.</li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>Наш выбор:</strong> Мы используем <code>localStorage</code>, потому что это проще для SPA и хорошо работает в нашей архитектуре. Мы принимаем риск XSS и боремся с ним другими методами (санитизация ввода, Content Security Policy). Для учебного проекта это оправданный компромисс. В проектах с высокими требованиями к безопасности часто выбирают HttpOnly cookies.
    </p>
  </div>

  <h2 id="guide">Справочник терминов (Claims)</h2>
  <p>Claims — это "утверждения" или поля внутри Payload токена. Вот самые важные:</p>
  <ul>
    <li><b>iss (Issuer)</b> — "Издатель". Кто выдал токен. У нас это "H2-2025-API". Помогает убедиться, что токен не от чужого сервиса.</li>
    <li><b>aud (Audience)</b> — "Аудитория". Для кого предназначен токен. У нас это "H2-2025-Client". Наше API не примет токен, предназначенный для другого клиента.</li>
    <li><b>sub (Subject)</b> — "Субъект". Главный герой токена, то есть пользователь. Обычно это его уникальный ID (<code>UserId</code>).</li>
    <li><b>exp (Expiration Time)</b> — "Время истечения". Когда токен превратится в тыкву. Указывается в формате Unix time (количество секунд с 1 января 1970 года).</li>
    <li><b>iat (Issued At)</b> — "Выдан в". Когда токен был создан. Тоже Unix time.</li>
    <li><b>jti (JWT ID)</b> — "ID токена". Уникальный идентификатор самого токена. Полезен, чтобы предотвратить повторное использование токена или отслеживать его.</li>
    <li><b>role</b> — "Роль". Наш кастомный claim, который мы добавляем. Содержит роль пользователя ("Admin", "Manager", "Kunde"), по которой сервер решает, куда его пускать.</li>
    <li><b>HS256 (HMAC using SHA-256)</b> — Название алгоритма подписи. Он берёт данные, наш секрет и создаёт из них хеш (подпись).</li>
    <li><b>Bearer Token</b> — Схема аутентификации. Когда мы пишем в заголовке <code>Authorization: Bearer &lt;token&gt;</code>, мы говорим: "Предъявителем этого токена является его владелец, пускайте его".</li>
  </ul>

  <div class="callout info">
    <div class="title">Где в проекте настраивается JWT</div>
    <ul>
      <li><code>API/Program.cs</code> — <b>AddJwtBearer</b> + параметры валидации и Events.OnMessageReceived для SignalR.</li>
      <li><code>API/Services/JwtService.cs</code> — сборка claims и подпись токена.</li>
      <li><code>API/Controllers/AuthController.cs</code> — логин, refresh, revoke.</li>
      <li><code>Blazor/Services/APIService.Auth.cs</code> — вход и сохранение токенов.</li>
      <li><code>Blazor/Services/APIService.TokenRefresh.cs</code> — автообновление при 401.</li>
    </ul>
  </div>

  <h2 id="lifecycle">Жизненный цикл токенов (в нашем проекте)</h2>
  <ol>
    <li><b>Вход:</b> Пользователь вводит логин/пароль. <code>AuthController</code> проверяет их и, если всё ок, вызывает <code>JwtService</code>.</li>
    <li><b>Выдача:</b> <code>JwtService</code> создаёт пару токенов: <code>access_token</code> (на 15 мин) и <code>refresh_token</code> (на 7 дней). Сервер сохраняет <strong>хеш</strong> refresh-токена в базу данных.</li>
    <li><b>Сохранение:</b> Клиент (Blazor) получает оба токена и сохраняет их в <code>localStorage</code>.</li>
    <li><b>Использование:</b> При каждом запросе к API клиент добавляет <code>access_token</code> в заголовок <code>Authorization: Bearer ...</code>. Сервер проверяет подпись и срок действия токена.</li>
    <li><b>Истечение срока:</b> Через 15 минут <code>access_token</code> "протухает". Запрос к API возвращает ошибку <code>401 Unauthorized</code>.</li>
    <li><b>Авто-обновление:</b> Клиентский сервис <code>TryWithTokenRefresh</code> перехватывает 401, берёт <code>refresh_token</code> и отправляет его на <code>/api/Auth/refresh-token</code>.</li>
    <li><b>Ротация:</b> Сервер проверяет <code>refresh_token</code>, помечает его как "использованный" и выдаёт <strong>новую пару</strong> access и refresh токенов.</li>
    <li><b>Повтор запроса:</b> Клиент сохраняет новую пару, обновляет заголовок Authorization и автоматически повторяет изначальный запрос, который теперь проходит успешно.</li>
    <li><b>Выход:</b> Пользователь нажимает "Выйти". Клиент отправляет запрос на <code>/api/Auth/revoke-all-tokens</code>. Сервер удаляет все refresh-токены этого пользователя из базы. Клиент чистит <code>localStorage</code>.</li>
  </ol>

  <h2 id="lab">Лаборатория: Собери свой токен</h2>
  <p>Локальный конструктор: создаст учебный JWT с подписью HS256 прямо в браузере.</p>
  <div class="builder">
    <div class="grid">
      <label>userId: <input type="number" @bind="BuilderUserId" /></label>
      <label>email: <input type="email" @bind="BuilderEmail" /></label>
      <label>role: <input type="text" @bind="BuilderRole" placeholder="Admin/Manager/Kunde" /></label>
      <label>issuer (iss): <input type="text" @bind="BuilderIssuer" placeholder="H2-2025-API" /></label>
      <label>audience (aud): <input type="text" @bind="BuilderAudience" placeholder="H2-2025-Client" /></label>
      <label>expires (мин): <input type="number" @bind="BuilderExpiryMinutes" /></label>
      <label>secret: <input type="text" @bind="BuilderSecret" placeholder="минимум 32 символа" /></label>
    </div>
    <button class="btn" @onclick="GenerateSampleJwt">Собрать токен</button>
    @if (!string.IsNullOrWhiteSpace(SampleToken))
    {
      <div class="token-out">
        <div>
          <div class="seg h">@SampleHeaderB64</div>
          <div class="seg p">@SamplePayloadB64</div>
          <div class="seg s">@SampleSignatureB64</div>
        </div>
        <div class="mono small">@SampleToken</div>
        <details>
          <summary>Раскрыть payload JSON</summary>
          <pre>@SamplePayloadJson</pre>
        </details>
      </div>
    }
  </div>

  <h2 id="http">HTTP кулинария (примеры запросов)</h2>
  <pre>
POST /api/Auth/register
Content-Type: application/json
{
  "username": "neo",
  "password": "m4trix",
  "email": "neo@matrix.io",
  "firstName": "Neo",
  "lastName": "ChosenOne"
}

POST /api/Auth/login
Content-Type: application/json
{
  "email": "neo@matrix.io",   // или username
  "password": "m4trix"
}
// Ответ: { accessToken, refreshToken, ... }
// Дальше все запросы с заголовком:
Authorization: Bearer &lt;accessToken&gt;

POST /api/Auth/refresh-token
Content-Type: application/json
{ "refreshToken": "&lt;refresh&gt;" }

POST /api/Auth/revoke-all-tokens   // при выходе
(нужен действующий access)
  </pre>

  <h2 id="quiz">Финальный КВИЗ RU/DA</h2>
  <p>Нажимай на варианты. Сразу увидишь «Верно/Неверно». Вопросы даны на русском/датском. Ответы перемешаны!</p>
  <div class="quiz">
    @for (int i = 0; i < _questions.Count; i++)
    {
        var questionIndex = i; // локальная копия для замыкания
        var q = _questions[questionIndex];
        <div class="q">
          <div class="qtext"><b>@(questionIndex+1).</b> @q.Text</div>
          <div class="opts">
            @for (int j = 0; j < q.Options.Count; j++)
            {
                var optionIndex = j; // локальная копия для замыкания
                var opt = q.Options[optionIndex];
                var chosen = q.SelectedIndex == optionIndex;
                var cls = q.Answered
                    ? (optionIndex == q.CorrectIndex ? "opt correct" : (chosen ? "opt wrong" : "opt"))
                    : (chosen ? "opt chosen" : "opt");
                <button class="@cls" type="button" @onclick="@(() => SelectAnswer(questionIndex, optionIndex))" disabled="@q.Answered">@opt</button>
            }
          </div>
          @if (q.Answered)
          {
            var isCorrect = q.SelectedIndex == q.CorrectIndex;
            <div class="feedback @(isCorrect ? "correct" : "wrong")">
                @(isCorrect ? "Верно! / Korrekt!" : "Неверно. / Forkert.")
            </div>
            @if (!string.IsNullOrWhiteSpace(q.Explanation))
            {
              <div class="explain"><b>Пояснение:</b> @q.Explanation</div>
            }
          }
        </div>
    }
    <div class="quiz-actions">
      <button class="btn" type="button" @onclick="ShowScore">Показать результат</button>
      <button class="btn ghost" type="button" @onclick="ResetQuiz">Сбросить</button>
    </div>
    @if (_scoreVisible)
    {
      <div class="score">Счёт: <b>@CorrectCount</b> из <b>@_questions.Count</b> — @(ScoreComment)</div>
    }
  </div>

  <h2>Финиш!</h2>
  <p>
    Если дочитал и прошёл квиз — ты приручил токены. Вернись в приложение и попробуй пройти реальный путь:
    логин → запросы → 401 → авто refresh → повтор → logout с revoke-all.
  </p>

  <div class="nav-buttons">
    <a href="/" class="btn">На главную</a>
  </div>
</div>

@code {
  // ===== Навигация по якорям =====
  private async Task ScrollToSection(string sectionId)
  {
      try
      {
          await JS.InvokeVoidAsync("eval", $"document.getElementById('{sectionId}')?.scrollIntoView({{ behavior: 'smooth', block: 'start' }});");
      }
      catch (Exception ex)
      {
          Console.WriteLine($"[SCROLL] Error scrolling to {sectionId}: {ex.Message}");
      }
  }

  // ===== Локальный конструктор JWT =====
  int BuilderUserId { get; set; } = 1;
  string BuilderEmail { get; set; } = "student@example.com";
  string BuilderRole { get; set; } = "Kunde";
  string BuilderIssuer { get; set; } = "H2-2025-API";
  string BuilderAudience { get; set; } = "H2-2025-Client";
  int BuilderExpiryMinutes { get; set; } = 60;
  string BuilderSecret { get; set; } = "this_is_a_demo_secret_with_32+_chars_length";

  string? SampleToken { get; set; }
  string SampleHeaderB64 { get; set; } = string.Empty;
  string SamplePayloadB64 { get; set; } = string.Empty;
  string SampleSignatureB64 { get; set; } = string.Empty;
  string SamplePayloadJson { get; set; } = string.Empty;

  void GenerateSampleJwt()
  {
      var now = DateTimeOffset.UtcNow;
      var iat = now.ToUnixTimeSeconds();
      var exp = now.AddMinutes(Math.Max(1, BuilderExpiryMinutes)).ToUnixTimeSeconds();

      var headerObj = new Dictionary<string, object> { ["alg"] = "HS256", ["typ"] = "JWT" };
      var payloadObj = new Dictionary<string, object>
      {
          ["sub"] = BuilderUserId.ToString(),
          ["email"] = BuilderEmail,
          ["role"] = BuilderRole,
          ["iss"] = BuilderIssuer,
          ["aud"] = BuilderAudience,
          ["iat"] = iat,
          ["exp"] = exp,
          ["jti"] = Guid.NewGuid().ToString()
      };

      var headerJson = JsonSerializer.Serialize(headerObj);
      var payloadJson = JsonSerializer.Serialize(payloadObj);

      var headerB64 = Base64UrlEncode(Encoding.UTF8.GetBytes(headerJson));
      var payloadB64 = Base64UrlEncode(Encoding.UTF8.GetBytes(payloadJson));
      var signature = ComputeHmacSha256($"{headerB64}.{payloadB64}", BuilderSecret);
      var signatureB64 = Base64UrlEncode(signature);

      SampleHeaderB64 = headerB64;
      SamplePayloadB64 = payloadB64;
      SampleSignatureB64 = signatureB64;
      SamplePayloadJson = payloadJson;
      SampleToken = $"{headerB64}.{payloadB64}.{signatureB64}";
  }

  static byte[] ComputeHmacSha256(string data, string secret)
  {
      using var h = new HMACSHA256(Encoding.UTF8.GetBytes(secret));
      return h.ComputeHash(Encoding.UTF8.GetBytes(data));
  }

  static string Base64UrlEncode(byte[] bytes)
  {
      return Convert.ToBase64String(bytes).TrimEnd('=') .Replace('+', '-') .Replace('/', '_');
  }

  // ===== Квиз =====
  class QuizQuestion
  {
      public string Text { get; set; } = string.Empty;
      public List<string> Options { get; set; } = new();
      public int CorrectIndex { get; set; }
      public string? Explanation { get; set; }
      public int? SelectedIndex { get; set; }
      public bool Answered { get; set; }
  }

  private List<QuizQuestion> _questions = new();
  private bool _scoreVisible;
  
  // Общий ГСЧ для перемешиваний
  private static readonly Random _rng = new Random();
  
  int CorrectCount => _questions.Count(q => q.Answered && q.SelectedIndex == q.CorrectIndex);
  string ScoreComment => CorrectCount switch
  {
      >= 10 => "Легенда токенов / Token-legende 🏆",
      >= 8 => "Гранд-мастер / Stormester ✨",
      >= 6 => "Уверенный / Sikker 👍",
      >= 4 => "База есть / Grundlag på plads 🙂",
      _ => "Нужно повторить / Skal gentages 🔁"
  };

  void SelectAnswer(int qi, int oi)
  {
      if (qi < 0 || qi >= _questions.Count) return;
      var q = _questions[qi];
      if (oi < 0 || oi >= q.Options.Count) return;

      q.SelectedIndex = oi;
      q.Answered = true;
      StateHasChanged();
      Console.WriteLine($"[QUIZ] Answer selected: Q={qi}, Opt={oi}, Correct={(oi == q.CorrectIndex)}");
  }

  void ShowScore()
  {
      _scoreVisible = true;
      StateHasChanged();
      Console.WriteLine($"[QUIZ] ShowScore clicked. Correct={CorrectCount}/{_questions.Count}");
  }

  void ResetQuiz()
  {
      // Пересобираем вопросы, чтобы заново перемешать варианты
      _questions = BuildQuestions();
      _scoreVisible = false;
      StateHasChanged();
      Console.WriteLine("[QUIZ] ResetQuiz clicked — questions randomized.");
  }

  protected override void OnInitialized()
  {
      if (_questions.Count == 0)
      {
          _questions = BuildQuestions();
          Console.WriteLine($"[QUIZ] Initialized. Questions={_questions.Count}");
      }
  }

  List<QuizQuestion> BuildQuestions()
  {
      return new List<QuizQuestion>
      {
          // ===== УРОВЕНЬ: БАЗА =====
          Q("Что такое JWT? / Hvad er JWT?",
            new[]{"Подписанный JSON-объект (цифровой пропуск) / Signeret JSON-objekt (digitalt adgangskort)","База данных в браузере / Browser-database","Зашифрованный файл / Krypteret fil", "Способ ускорить сайт / En måde at gøre en hjemmeside hurtigere på"}, 0,
            "JWT — это стандарт для создания токенов, которые удостоверяют личность и права. Это как пропуск с подписью, который нельзя подделать."),

          Q("Какие три части у JWT? / Hvad består et JWT af?",
            new[]{"Header, Payload, Signature (Заголовок, Данные, Подпись)","User, Pass, Secret","Issuer, Audience, Subject", "GET, POST, PUT"}, 0,
            "Токен состоит из трёх частей в кодировке Base64Url, соединённых точками."),

          Q("Зачем нужна подпись (Signature)? / Hvorfor er signaturen nødvendig?",
            new[]{"Чтобы гарантировать, что данные не подделаны / For at garantere, at data ikke er forfalsket","Чтобы зашифровать данные / For at kryptere data","Чтобы уменьшить размер токена / For at reducere tokenets størrelse", "Чтобы указать, кто выдал токен / For at angive, hvem der har udstedt tokenet"}, 0,
            "Подпись — это гарантия целостности. Если изменить хоть один символ в Payload, подпись станет недействительной."),

          Q("Зачем нужен refresh-токен? / Hvorfor har vi brug for et refresh-token?",
            new[]{"Чтобы безопасно получить новый access-токен, когда старый истёк / For sikkert at få et nyt access-token, når det gamle er udløbet","Для входа в систему вместо пароля / Til at logge ind i stedet for en adgangskode","Для хранения данных профиля пользователя / Til at gemme brugerens profildata", "Чтобы выходить из системы / For at logge ud af systemet"}, 0,
            "Access-токен живёт недолго для безопасности. Refresh-токен позволяет обновлять его без повторного ввода пароля."),

          // ===== УРОВЕНЬ: СРЕДНИЙ =====
          Q("Почему access-токен делают короткоживущим? / Hvorfor har access-tokens en kort levetid?",
            new[]{"Чтобы уменьшить риск при краже / For at mindske risikoen ved tyveri","Чтобы чаще запрашивать refresh / For at anmode om refresh oftere","Чтобы снизить нагрузку на сервер / For at reducere serverbelastningen", "Потому что так требует стандарт / Fordi standarden kræver det"}, 0,
            "Если access-токен украдут, злоумышленник сможет использовать его лишь короткое время (например, 15 минут)."),

          Q("Что такое 'ротация' refresh-токенов? / Hvad er rotation af refresh-tokens?",
            new[]{"Когда старый refresh-токен используется, он отзывается и выдаётся новый / Når et gammelt refresh-token bruges, tilbagekaldes det, og et nyt udstedes","Когда меняется роль пользователя / Når brugerens rolle ændres","Когда меняется алгоритм подписи токена / Når tokenets signaturalgoritme ændres", "Когда пользователь меняет пароль / Når brugeren ændrer sin adgangskode"}, 0,
            "Ротация — ключевой механизм безопасности. Она позволяет обнаружить кражу и повторное использование refresh-токена."),

          Q("Где клиент хранит токены в нашем проекте? / Hvor gemmer klienten tokens i vores projekt?",
            new[]{"В localStorage / I localStorage","В Cookies (HttpOnly)","В sessionStorage", "В памяти (in-memory)"}, 0,
            "Мы используем localStorage, потому что это просто и удобно для SPA-приложений. Но это делает токены уязвимыми для XSS-атак."),

          Q("Что произойдёт, если сервер получит запрос с истёкшим access-токеном? / Hvad sker der, hvis serveren modtager en anmodning med et udløbet access-token?",
            new[]{"Вернёт ошибку 401 Unauthorized / Returnerer en 401 Unauthorized-fejl","Автоматически обновит токен / Fornyer automatisk tokenet","Проигнорирует срок действия / Ignorerer udløbstiden", "Удалит пользователя / Sletter brugeren"}, 0,
            "Сервер строго проверяет claim 'exp'. Ошибка 401 — это сигнал для клиента, что пора обновить токен."),

          // ===== УРОВЕНЬ: СЛОЖНЫЙ =====
          Q("В чём главное преимущество JWT перед сессиями? / Hvad er den største fordel ved JWT i forhold til sessioner?",
            new[]{"Отсутствие состояния на сервере (Stateless) / Stateless (ingen tilstand på serveren)","Более высокий уровень безопасности / Højere sikkerhedsniveau","Меньший размер / Mindre størrelse", "Простота использования / Nemmere at bruge"}, 0,
            "Серверу не нужно хранить информацию о сессии. Вся информация находится в самом токене, что упрощает масштабирование."),

          Q("Что произойдёт при повторном использовании отозванного refresh-токена (reuse detection)? / Hvad sker der ved genbrug af et tilbagekaldt refresh-token (reuse detection)?",
            new[]{"Все активные токены этого пользователя будут отозваны / Alle aktive tokens for denne bruger vil blive tilbagekaldt","Ничего, запрос будет просто отклонён / Intet, anmodningen vil blot blive afvist","Пользователь получит email с предупреждением / Brugeren vil modtage en advarsels-e-mail", "Аккаунт пользователя будет заблокирован / Brugerens konto vil blive blokeret"}, 0,
            "Это мера безопасности против кражи. Сервер отзывает всю семью токенов, чтобы выкинуть и легитимного пользователя, и хакера, заставляя пройти повторную аутентификацию."),
            
          Q("Как в C# на сервере потребовать роль 'Admin' для доступа к эндпоинту? / Hvordan kræver man 'Admin'-rollen for adgang til et endpoint i C# på serveren?",
            new[]{"Атрибутом [Authorize(Roles=\"Admin\")] / Med attributten [Authorize(Roles=\"Admin\")]","Методом CheckRole(\"Admin\")","Конфигурацией в appsettings.json", "Атрибутом [RequiresRole(\"Admin\")]"}, 0,
            "Атрибут [Authorize] с параметром Roles — это стандартный механизм в ASP.NET Core для проверки ролей из claims токена."),

          Q("Почему хранить токены в HttpOnly cookie считается безопаснее, чем в localStorage? / Hvorfor anses det for mere sikkert at gemme tokens i en HttpOnly-cookie end i localStorage?",
            new[]{"JavaScript не может получить к ним доступ, что защищает от XSS / JavaScript kan ikke få adgang til dem, hvilket beskytter mod XSS","Они автоматически шифруются браузером / De krypteres automatisk af browseren","Они не отправляются на сервер с каждым запросом / De sendes ikke til serveren med hver anmodning", "У них нет срока действия / De har ingen udløbsdato"}, 0,
            "Главный враг localStorage — это XSS-атаки, которые могут украсть токен. Флаг HttpOnly в cookie запрещает доступ к нему из скриптов, решая эту проблему."),

          // ===== ДОП. ВОПРОСЫ ДЛЯ 35 =====
          Q("Что такое Base64Url и зачем он в JWT? / Hvad er Base64Url og hvorfor i JWT?",
            new[]{"Безопасная для URL версия Base64 / URL-sikker Base64-variant","Алгоритм шифрования / Krypteringsalgoritme","Тип подписи / Signaturtype", "Формат JSON / JSON-format"}, 0,
            "JWT части кодируются Base64Url, чтобы символы не конфликтовали в URL (замены +/ на -_ и без =)."),

          Q("Какой claim задаёт срок действия токена? / Hvilket claim angiver udløbstiden?",
            new[]{"exp","iat","iss","aud"}, 0,
            "exp (Expiration Time) — время, когда токен становится недействительным."),

          Q("Что означает iat? / Hvad betyder iat?",
            new[]{"Время выдачи токена / Udstedelsestid","Роль пользователя / Brugerrolle","Идентификатор токена / Token-id", "Получатель токена / Modtager"}, 0,
            "iat (Issued At) — метка времени создания токена."),

          Q("Для чего нужен claim iss (Issuer)? / Hvad bruges iss til?",
            new[]{"Кто выдал токен / Hvem udstedte tokenet","Для кого токен / Hvem tokenet er til","Срок действия / Udløbstid", "Уникальный id токена / Unikt token-id"}, 0,
            "Issuer помогает убедиться, что токен от нашего сервера, а не чужого."),

          Q("Для чего нужен claim aud (Audience)? / Hvad bruges aud til?",
            new[]{"Для какого клиента токен / Hvilken klient tokenet er til","Кто выдал токен / Hvem udstedte tokenet","Идентификатор пользователя / Bruger-id", "Список ролей / Rolleliste"}, 0,
            "Audience ограничивает использование токена конкретной аудиторией (клиентом)."),

          Q("Что такое sub (Subject) в токене? / Hvad er sub i tokenet?",
            new[]{"Идентификатор пользователя / Brugerens id","Подпись токена / Tokens signatur","Получатель токена / Tokenets modtager", "Секретный ключ / Hemmelig nøgle"}, 0,
            "Обычно это UserId — главный субъект токена."),

          Q("Что такое jti? / Hvad er jti?",
            new[]{"Уникальный идентификатор токена / Unikt token-id","Тип подписи / Signaturtype","Имя пользователя / Brugernavn", "Версия API / API-version"}, 0,
            "jti помогает отслеживать и при желании отзывать конкретные токены."),

          Q("Можно ли читать Payload JWT без ключа? / Kan man læse payload uden nøgle?",
            new[]{"Да, он не шифрован / Ja, den er ikke krypteret","Нет, нужен секрет / Nej, der kræves hemmelighed","Только админы / Kun admins", "Только через сервер / Kun via server"}, 0,
            "JWT по умолчанию подписан, но не зашифрован — содержимое можно декодировать."),

          Q("Где обычно передают access-токен? / Hvor sendes access-token typisk?",
            new[]{"В заголовке Authorization: Bearer ...","В теле POST","В query-параметре","В cookie без флагов"}, 0,
            "Стандарт — заголовок Authorization со схемой Bearer."),

          Q("Какой код у невалидного/истёкшего токена? / Hvilken kode ved ugyldigt/udløbet token?",
            new[]{"401 Unauthorized","403 Forbidden","400 Bad Request","409 Conflict"}, 0,
            "Неверная подпись/истёкший токен → 401. 403 — когда прав не хватает."),

          Q("Что означает 403 в контексте JWT? / Hvad betyder 403?",
            new[]{"Недостаточно прав / Manglende tilladelser","Токен истёк / Token udløbet","Нет токена / Intet token", "Внутренняя ошибка / Intern fejl"}, 0,
            "403 означает, что аутентификация может быть ок, но авторизации недостаточно."),

          Q("В чём плюс RS256 по сравнению с HS256? / Fordel ved RS256 vs HS256?",
            new[]{"Разделение приватного/публичного ключа / Opdeling af privat/offentlig nøgle","Меньший размер токена / Mindre tokenstørrelse","Быстрее подпись / Hurtigere signatur", "Не нужен iss/aud / Iss/aud ikke nødvendig"}, 0,
            "RS256 позволяет проверять подпись публичным ключом, не раскрывая приватный на всех серверах."),

          Q("Что хранится в БД для refresh-токена? / Hvad gemmes i DB for refresh-token?",
            new[]{"Хеш токена / Tokenets hash","Сам токен целиком / Hele tokenet","Только exp / Kun exp", "Ничего / Intet"}, 0,
            "Храним хеш (TokenHash), чтобы утечка БД не давала злоумышленнику рабочий токен."),

          Q("Зачем валидационный параметр ClockSkew = 0? / Hvorfor ClockSkew = 0?",
            new[]{"Не давать лишних секунд после истечения / Ingen ekstra margin efter udløb","Ускорить сервер / Gøre serveren hurtigere","Шифровать токен / Kryptere token", "Увеличить срок жизни / Forlænge levetid"}, 0,
            "По умолчанию есть доп. окно ~5 минут. Мы отключаем его для строгой безопасности."),

          Q("Что делает logout в нашем проекте? / Hvad gør logout?",
            new[]{"Отзывает все refresh-токены и чистит хранилище / Tilbagekalder alle refresh-tokens og rydder storage","Удаляет пользователя / Sletter brugeren","Меняет пароль / Ændrer adgangskode", "Только скрывает кнопки / Skjuler kun knapper"}, 0,
            "Вызываем revoke-all на сервере и удаляем токены на клиенте."),

          Q("Где хранить секретный ключ JWT сервера? / Hvor opbevares JWT-hemmeligheden?",
            new[]{"В переменных окружения/секретах / I miljøvariabler/secrets","В Git-репозитории / I Git","В localStorage","В comment в коде"}, 0,
            "Секрет должен быть вне репозитория — в конфигурации/секретах окружения."),

          Q("Можно ли класть пароли в JWT? / Må man lægge adgangskoder i JWT?",
            new[]{"Нет, никогда / Nej, aldrig","Да, если шифровать / Ja, hvis krypteret","Да, но только admin / Ja, men kun admin", "Только в refresh / Kun i refresh"}, 0,
            "JWT читаем любым — пароли и секреты хранить нельзя."),

          Q("Главный риск localStorage для токенов? / Hvad er hovedrisikoen ved localStorage?",
            new[]{"XSS-атаки / XSS-angreb","CSRF-атаки / CSRF-angreb","SQL-инъекции / SQL-injektioner", "DDoS"}, 0,
            "При XSS злоумышленник может вытащить токены из localStorage."),

          Q("Какой флаг cookie снижает риск CSRF? / Hvilket cookie-flag mindsker CSRF?",
            new[]{"SameSite=Strict","HttpOnly","Secure","Domain"}, 0,
            "SameSite=Strict ограничивает отправку cookie только с того же сайта."),

          Q("Как сервер проверяет роль в токене? / Hvordan tjekker serveren rollen?",
            new[]{"Claim 'role' / Claim 'role'","Claim 'aud'","Claim 'sub'", "Claim 'jti'"}, 0,
            "В ASP.NET Core роль берётся из claim 'role' (ClaimTypes.Role)."),

          Q("В каком формате exp/iat в JWT? / Hvilket format for exp/iat?",
            new[]{"Unix time (секунды) / Unix-tid (sekunder)","ISO 8601","DateTime.Ticks","RFC1123"}, 0,
            "Стандарт — количество секунд с 1 января 1970 UTC."),

          Q("Что будет, если изменить один символ в Payload? / Hvad hvis man ændrer et tegn i payload?",
            new[]{"Подпись не совпадёт, токен отвергнут / Signaturen matcher ikke, token afvises","Токен сам исправится","Сервер ничего не заметит", "Будет 302 Redirect"}, 0,
            "Любое изменение данных ломает подпись — проверка провалится."),

          Q("Где настраивается проверка JWT в ASP.NET Core? / Hvor konfigureres JWT-validering?",
            new[]{"AddAuthentication().AddJwtBearer(...)","Startup.cs ConfigureRouting()","appsettings.json только","В контроллерах"}, 0,
            "В Program.cs через AddAuthentication + AddJwtBearer и TokenValidationParameters."),

          // ===== ДОБАВЛЕНИЕ: чтобы довести до 35 =====
          Q("Что означает схема 'Bearer' в заголовке? / Hvad betyder 'Bearer'-skemaet?",
            new[]{"Кто предъявил токен, тот и владелец доступа / Den der fremviser token, har adgang","Токен одноразовый / Engangs-token","Только для админов / Kun for admins","Токен хранится в cookie / Token opbevares i cookie"}, 0,
            "Authorization: Bearer <token> — сервер доверяет предъявителю токена."),

          Q("Может ли токен содержать несколько ролей? / Kan et token have flere roller?",
            new[]{"Да, несколько claims 'role' / Ja, flere 'role'-claims","Нет, только одну / Nej, kun én","Только у Admin / Kun hos Admin","Только в refresh / Kun i refresh"}, 0,
            "Можно добавить несколько 'role' claims."),

          Q("Что должен делать клиент при 401? / Hvad gør klienten ved 401?",
            new[]{"Попробовать refresh и повторить запрос / Forsøg refresh og gentag","Сразу logout","Игнорировать ошибку","Менять роль на Admin"}, 0,
            "В проекте это делает TryWithTokenRefresh: обновляет и повторяет."),

          Q("Типичный срок жизни refresh-токена в примере? / Typisk levetid for refresh-token?",
            new[]{"Несколько дней/около недели / Nogle dage/omkring en uge","15 минут","1 минута","Навсегда"}, 0,
            "В учебном проекте ~7 дней (а access — 15 минут)."),

          Q("Чем отличается access от refresh? / Hvad er forskellen på access og refresh?",
            new[]{"Access в каждом запросе, refresh только для обновления / Access i hver anmodning, refresh kun til fornyelse","Refresh быстрее","Access хранится в БД","Разницы нет"}, 0,
            "Access — рабочий пропуск; refresh — мастер-ключ для продления."),

          Q("Где лучше перехватывать 401 на клиенте? / Hvor fanges 401 bedst på klienten?",
            new[]{"В общей HTTP-обёртке/интерсепторе / I en fælles HTTP-indpakning","В каждой кнопке","На сервере","В CSS"}, 0,
            "У нас это обёртка TryWithTokenRefresh."),

          Q("Какой алгоритм подписи используется в примере? / Hvilken signaturalgoritme bruges i eksemplet?",
            new[]{"HS256","RS256","ES256","none"}, 0,
            "Header содержит alg: HS256 (HMAC-SHA256)."),

          Q("Сколько минут живёт access_token в примере? / Hvor mange minutter lever access_token i eksemplet?",
            new[]{"15 минут","5 минут","60 минут","1440 минут"}, 0,
            "В JwtService expires: DateTime.UtcNow.AddMinutes(15)."),

          Q("Как выглядит заголовок с токеном? / Hvordan ser headeren med token ud?",
            new[]{"Authorization: Bearer <token>","Auth: JWT <token>","X-Token: <token>","Cookie: token=<token>"}, 0,
            "Стандарт — Authorization со схемой Bearer."),

          Q("За что отвечает ValidateIssuer? / Hvad gør ValidateIssuer?",
            new[]{"Проверяет издателя (iss) / Tjekker udsteder (iss)","Проверяет срок (exp)","Проверяет аудиторию (aud)","Проверяет роль (role)"}, 0,
            "Сравниваем iss с ожидаемым значением из конфигурации."),

          Q("За что отвечает ValidateAudience? / Hvad gør ValidateAudience?",
            new[]{"Проверяет аудиторию (aud)","Проверяет издателя (iss)","Проверяет срок (exp)","Проверяет подпись"}, 0,
            "aud должен совпадать с нашим клиентом (ValidAudience)."),

          Q("За что отвечает ValidateLifetime? / Hvad gør ValidateLifetime?",
            new[]{"Проверяет срок действия (exp/nbf)","Проверяет роль","Проверяет алгоритм","Проверяет issuer"}, 0,
            "Отсекает истёкшие/ещё не начавшиеся токены (учитывая ClockSkew)."),

          Q("За что отвечает ValidateIssuerSigningKey? / Hvad gør ValidateIssuerSigningKey?",
            new[]{"Проверяет подпись ключом / Validerer signatur med nøgle","Включает HTTPS","Отключает кэш","Проверяет роль"}, 0,
            "Подпись сверяется с IssuerSigningKey (наш секрет)."),

          Q("Что делает сервер при успешном refresh? / Hvad gør serveren ved en vellykket refresh?",
            new[]{"Выдаёт новую пару access+refresh и помечает старый refresh использованным","Только продлевает старый access","Удаляет пользователя","Меняет пароль"}, 0,
            "Ротация: новая пара и отзыв старого refresh-токена."),

          Q("Где в проекте настраиваются параметры валидации JWT? / Hvor i projektet konfigureres valideringsparametre?",
            new[]{"API/Program.cs","API/Controllers/AuthController.cs","Blazor/Program.cs","Blazor/Services/APIService.Auth.cs"}, 0,
            "В Program.cs при AddAuthentication().AddJwtBearer(...)."),

          // конец списка — всего 35 вопросов
      };
  }

  static QuizQuestion Q(string text, string[] options, int correct, string? explanation = null)
  {
      // Перемешиваем варианты и вычисляем новый индекс правильного
      var opts = options.ToList();
      if (opts.Count == 0) throw new ArgumentException("Options must not be empty");
      if (correct < 0 || correct >= opts.Count) throw new ArgumentOutOfRangeException(nameof(correct));

      var correctValue = opts[correct];

      // Fisher–Yates shuffle
      for (int i = opts.Count - 1; i > 0; i--)
      {
          int j = _rng.Next(i + 1);
          (opts[i], opts[j]) = (opts[j], opts[i]);
      }

      // Находим новый индекс правильного варианта
      var newCorrectIndex = opts.FindIndex(o => string.Equals(o, correctValue, StringComparison.Ordinal));
      if (newCorrectIndex < 0) newCorrectIndex = 0; // подстраховка на случай дубликатов

      return new QuizQuestion
      {
          Text = text,
          Options = opts,
          CorrectIndex = newCorrectIndex,
          Explanation = explanation
      };
  }
}
